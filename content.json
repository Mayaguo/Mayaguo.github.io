{"meta":{"title":"GMaya","subtitle":"生命不止，奋斗不息。","description":"一分耕耘，一分收获。","author":"GMaya","url":"https://gmaya.top","root":"/"},"pages":[{"title":"标签","date":"2020-01-01T04:39:04.000Z","updated":"2020-03-11T03:27:39.167Z","comments":false,"path":"tags/index.html","permalink":"https://gmaya.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-01-01T04:39:04.000Z","updated":"2020-03-11T03:25:48.154Z","comments":false,"path":"categories/index.html","permalink":"https://gmaya.top/categories/index.html","excerpt":"","text":""},{"title":"简单却不平凡","date":"2019-12-26T07:35:07.000Z","updated":"2020-03-11T14:17:18.051Z","comments":true,"path":"about/index.html","permalink":"https://gmaya.top/about/index.html","excerpt":"","text":"个人介绍 一名来自河南的95后小伙，至今一直杭漂在外，目前主要负责公司项目Java后端技术开发，平时业余自学EPL，在社区写一些酷q插件，可爱猫插件。我想说的就是，我不穿格子衫，不掉头发！也没有秃顶！！喜欢打球，听歌，上网！也很喜欢钻研，喜欢一个人静静的做自己喜欢的事。 联系方式：QQ: 1427097103邮箱：gmaya@qq.com 博客介绍 我个人觉得如果不把经历过的错误以及解决办法记录下来，如果时隔一年半载，再次遇到，大几率还是面向百度。。 好记性不如烂笔头，自己亲手搭建个博客，亲手写一遍，亲手再整理一遍，我觉得经历的越多，时间越久，收获就更大！ 主要就是记录我平时工作遇到的问题，以及解决办法。能为下次遇到提供最正确的解决办法。"}],"posts":[{"title":"Linux下安装RabbitMQ入门级别","slug":"20200409","date":"2020-04-09T12:18:12.000Z","updated":"2020-04-09T12:23:13.418Z","comments":true,"path":"2020/20200409/","link":"","permalink":"https://gmaya.top/2020/20200409/","excerpt":"","text":"Linux安装RabbitMQ安装erlang环境 由于RabbitMQ是基于Erlang（面向高并发的语言）语言开发，所以在安装RabbitMQ之前，需要先安装Erlang。 123yum -y install epel-releaseyum -y updateyum -y install erlang socat 查看erlang版本 1erl -version 安装RabbitMQ下载RabbitMQ 1wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm 提示: 如果你没有wget,请先安装wget 1yum -y install wget 安装RabbitMQ 1yum install rabbitmq-server-3.6.15-1.el7.noarch.rpm 配置添加开机启动RabbitMQ服务 1systemctl enable rabbitmq-server.service 启动web控制台 1rabbitmq-plugins enable rabbitmq_management 防火墙开放15672和5672端口 12/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT/sbin/iptables -I INPUT -p tcp --dport 5672 -j ACCEPT 默认网页guest用户是不允许访问的，需要修改一下权限 修改配置文件 1vi /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app 启动, 停止 , 重启 123service rabbitmq-server startservice rabbitmq-server stopservice rabbitmq-server restart 注：有可能起不来 。。。 进入 1cd /usr/lib/rabbitmq/bin 启动 加 -detached 后台启动 1./rabbitmq-server start -detached 浏览器输入ip:15672输入guest guest 服气，各种版本不一致问题，提不起来，项目访问不到，端口不通，这个安装感觉比oracle都麻烦！！！","categories":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/categories/Java/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://gmaya.top/tags/RabbitMQ/"}]},{"title":"Java中的多重for循环怎么跳出最外层","slug":"20200408","date":"2020-04-08T06:01:12.000Z","updated":"2020-04-08T06:03:48.024Z","comments":true,"path":"2020/20200408/","link":"","permalink":"https://gmaya.top/2020/20200408/","excerpt":"","text":"笔记记录不加任何代码,最里层的break,只能跳出最内层的循环, 如果想要跳出最外面的,就要新增一个标记.在想要跳出循环的地方加标记,然后break标记. 同理换成continue 标记; 效果一样. 12345678910111213141516/** * 测试多重for循环 break */public static void forTest() &#123; int a = 3; tab: for (int i = 0; i &lt; a; i++) &#123; System.out.println(\"我是i....\" + i); for (int j = 0; j &lt; a; j++) &#123; System.out.println(\"我是j....\" + j); if (j == 1) &#123; break tab; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/tags/Java/"}]},{"title":"Python一键获取所有高清无码王者皮肤图片","slug":"20200406","date":"2020-04-06T08:20:33.000Z","updated":"2020-04-06T08:20:45.809Z","comments":true,"path":"2020/20200406/","link":"","permalink":"https://gmaya.top/2020/20200406/","excerpt":"","text":"前言突然看到王者荣耀每个英雄的图片很不错,所有就一张一张保存了. 分析1.打开王者荣耀官方英雄列表2.分析接口3.实际操作4.调整代码5.开始启动程序 开始其中中间发现,获取的页面中并没有直接找到图片的地址, 所以先拿到皮肤名称拼接成图片链接,然后真正拿到高清无码皮肤图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# -*- coding: gbk -*-## -------------------------------------------------------# Name: WZRYImpageDemo# Description: 多线程获取王者荣耀所有英雄高清皮肤# Author: GMaya# Date: 2020/4/6 14:56# -------------------------------------------------------import threadingimport requests, json, re# 创建会话对象session = requests.session()headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.87 Safari/537.36', 'origin': 'https://pvp.qq.com'&#125;# 获取所有英雄列表def get_hero_list(): # 请求接口 result = session.get('https://pvp.qq.com/web201605/js/herolist.json', headers=headers) # 解析json结果 resJson = json.loads(result.text) for res in resJson: # 英雄名称 cname = res.get('cname') # 英雄详情页id ename = res.get('ename') # 多线程获取详细页 myThread(cname, ename).start()# 获取英雄详情页面信息def get_hero_tail(ename, cname): # 请求接口 result = session.get('https://pvp.qq.com/web201605/herodetail/%s.shtml' % ename, headers=headers) result.encoding = 'gbk' zz = \"\"\"&lt;ul class=\"pic-pf-list pic-pf-list3\" data-imgname=\"(.*?)\"&gt;\"\"\" # 由于爬取的页面和网页上看到的实际效果不一致,所以这里拿取所有皮肤名称,直接去皮肤服务器拿取 res_tail = re.findall(zz, result.text)[0] res_tail_list = res_tail.split('|') count = 1 for tail in res_tail_list: imgName = cname + '-' + tail # 下载具体图片 get_hero_skin(ename, count, imgName) count += 1# 保存下载图片def get_hero_skin(ename, i, imgName): url = \"http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/%s/%s-bigskin-%d.jpg\" % (ename, ename, i) # 拼接最后的图片地址,然后保存 res_skin = session.get(url) file = 'D:\\download\\爬虫图片目录\\王者荣耀图片\\%s.jpg' % imgName # wb : 以二进制格式打开一个文件只用于写入。一般用于非文本文件如图片等。 with open(file, 'wb') as f: f.write(res_skin.content)# 创建线程类class myThread(threading.Thread): def __init__(self, cname, ename): threading.Thread.__init__(self) self.cname = cname self.ename = ename def run(self): print(\"开始线程：\" + self.cname) try: get_hero_tail(self.ename, self.cname) except Exception: print('线程出现意外....' + self.name) print(\"退出线程：\" + self.cname)if __name__ == '__main__': # 开始 get_hero_list() 也没有具体的计算, 这三百多个将近四百个, 其中包含英雄本身的图片,所以真正的皮肤应该是200多个.应该是全了.说实话,300kb左右的图片, 已经很清楚了","categories":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/tags/Python/"}]},{"title":"Python听说网易云音乐的评论很有意思","slug":"20200405","date":"2020-04-05T15:22:33.000Z","updated":"2020-04-05T16:12:57.709Z","comments":true,"path":"2020/20200405/","link":"","permalink":"https://gmaya.top/2020/20200405/","excerpt":"","text":"前言听歌哪个平台好不知道， 但是要说评论，那就是网易云音乐。看看云音乐热歌榜所有歌曲的评论吧。 分析其实重点是分析各个页面和接口， 只要分析到位，没有拿不到的信息。 代码其中headers和data 的信息自己从浏览器拿一下就好了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: utf-8 -*-## -------------------------------------------------------# Name: Music163# Description: 获取网易云音乐精彩评论# Author: GMaya# Date: 2020/4/5 21:45# -------------------------------------------------------import requests, re, json, datetime# 1.创建会话对象session = requests.session()headers = &#123; 'User-Agent': 'xxx'&#125;data = &#123; \"params\": \"xxx\" , \"encSecKey\": \"xxx\"&#125;# 文件保存位置file = 'D:\\download\\music163.txt'# 根据歌曲id 获取所有精彩评论def get_music_comment(songid): url = \"https://music.163.com/weapi/v1/resource/comments/R_SO_4_%d?csrf_token=\" % songid result = session.post(url, headers=headers, data=data) res = json.loads(result.text) hotComments = res.get('hotComments') for hot in hotComments: # 热评内容 content = hot.get('content').replace('\\n', '') # 昵称 nickname = hot.get('user').get('nickname') # 评论时间 hottime = int(hot.get('time')) / 1000 hottime = datetime.datetime.fromtimestamp(hottime).strftime('%Y-%m-%d %H:%M:%S') # 点赞人数 likedCount = hot.get('likedCount') consequence = '[昵称:]%s,[评论时间:]%s,[点赞人数:]%d,[热评内容:]%s' % (nickname, hottime, likedCount, content) # 保存评论信息 with open(file, 'a+', encoding='utf-8') as f: f.write(consequence + '\\n') # 加\\n换行显示# 获取热歌排行榜所有歌曲iddef get_song(): url = \"https://music.163.com/m/discover/toplist?id=3778678\" result = session.get(url, headers=headers) res = \"\"\"&lt;ul class=\"f-hide\"&gt;(.*?)&lt;/ul&gt;\"\"\" resul = re.findall(res, result.text) print(resul) for ress in resul: res2 = \"\"\"&lt;li&gt;&lt;a href=\"\\/song\\?id=(.*?)\"&gt;(.*?)&lt;/a&gt;&lt;/li&gt;\"\"\" resul2 = re.findall(res2, ress) # print(resul2) for r in resul2: songid = int(r[0]) songname = r[1] print(\"开始下载[%s]歌曲评论\" % songname) consequence = '===========歌曲名称: %s===============' % songname with open(file, 'a+', encoding='utf-8') as f: f.write(consequence + '\\n') # 加\\n换行显示 # 开始下载评论 get_music_comment(songid)if __name__ == '__main__': get_song() 最后文件是保存到本地磁盘, 还是数据库,根据自己的方式决定 思路:我之前写过获取qq音乐分享链接可以根据歌名 获得到歌曲id等链接, 这个网易云根据歌名获取歌曲id也不难,这个时候应该可以做一个对接qq或者微信的机器人, 用户在qq群输入歌名,直接返回最热的一条评论!","categories":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/tags/Python/"}]},{"title":"Python一键珍藏我的动漫妹子们","slug":"20200404","date":"2020-04-04T10:02:31.000Z","updated":"2020-04-04T10:07:14.406Z","comments":true,"path":"2020/20200404/","link":"","permalink":"https://gmaya.top/2020/20200404/","excerpt":"","text":"前言获取点动漫图片,还要一张一张保存,这多难受.话不多说,练练手 分析获取图片步骤: 找到图片来源网站 分析网站页面数据结构 分析下一页结果 分析数据处理 保存 本次找到的图片来源是http://pic.netbian.com/4kdongman/index.html都是高清4k动漫大妹子 然后F12找到图片位置的标签等,然后使用正则匹配 点击下一个看到,后缀 index_2 index_3 所以,下一页数据只需要下划线加本页页数即可 开鲁代码 展示真正的技术12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# -*- coding=gbk -*-# @Author: GMaya# 爬取动漫图片,嘎嘎import requests, time, re# 1.创建会话对象session = requests.session()# 获取目标网页结果def get_result(url): # 请求接口 result = session.get(url) # 编码格式 result.encoding = 'gbk' \"\"\" 正则表达式,匹配对应数据 注意:href=\"(.*?)\" , 如果 .*? 被括号包裹, 则输出括号内的内容 如果没有括号, 则输出整个匹配的内容 \"\"\" res = \"\"\"&lt;a href=\"(.*?)\" target=\"_blank\"&gt;&lt;img src=\".*?\" alt=\".*?\" /&gt;&lt;b&gt;.*?&lt;/b&gt;&lt;/a&gt;\"\"\" # 匹配符合正则内容 return re.findall(res, result.text)# 解析详情页数据def two_result(contents): for con in contents: # 去第详情页,获取清晰度比较高的图片 result2 = session.get('http://pic.netbian.com/' + con) result2.encoding = 'gbk' res2 = \"\"\"&lt;a href=\"\" id=\"img\"&gt;&lt;img src=\"(.*?)\" data-pic=\".*?\" alt=\"(.*?)\" title=\".*?\"&gt;&lt;/a&gt;\"\"\" # 匹配符合正则内容 contents2 = re.findall(res2, result2.text) # 真正处理数据并保存 save_result(contents2)# 真正处理数据并保存def save_result(contents2): for con2 in contents2: path = con2[0] # 图片真正的高清图片地址 name = con2[1] # 图片名称 # 拼接最后的图片地址,然后保存 result3 = session.get('http://pic.netbian.com/' + path) file = 'D:\\download\\dongmanImg\\%s.jpg' % name # wb : 以二进制格式打开一个文件只用于写入。一般用于非文本文件如图片等。 with open(file, 'wb') as f: f.write(result3.content) # 安全点就等待0.5秒再次爬取 time.sleep(0.5)if __name__ == '__main__': print('下载动漫图片开始--------------') # 爬取前一百页内容 pageno = 100 # 1.请求网页,获取结果 for i in range(1, pageno): print('解析处理第%d页数据 请稍等...' % i) # 第一个和其他页有点不同,所以分开处理 url = '' if i == 1: url = \"http://pic.netbian.com/4kdongman/index.html\" else: url = \"http://pic.netbian.com/4kdongman/index_%d.html\" % i # 得到网页响应结果 result = get_result(url) # 处理详情页数据 two_result(result) print('第%d页数据共%d个,处理完毕.' % (i, len(result))) # 每次请求间隔0.5秒 time.sleep(0.5) print('下载动漫图片结束--------------') 喝陪咖啡,静等一会 说明: 只是用作技术练习.请勿恶意使用 多线程爬取上面单线程爬取了两杯咖啡时间, 到30页的时候,我停止了,太慢了,咋办,多线程搞上! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# -*- coding=gbk -*-# @Author: GMaya# 爬取动漫图片,多线程例子import requests, time, reimport threading# 1.创建会话对象session = requests.session()# 获取目标网页结果def get_result(url): # 请求接口 result = session.get(url) # 编码格式 result.encoding = 'gbk' \"\"\" 正则表达式,匹配对应数据 注意:href=\"(.*?)\" , 如果 .*? 被括号包裹, 则输出括号内的内容 如果没有括号, 则输出整个匹配的内容 \"\"\" res = \"\"\"&lt;a href=\"(.*?)\" target=\"_blank\"&gt;&lt;img src=\".*?\" alt=\".*?\" /&gt;&lt;b&gt;.*?&lt;/b&gt;&lt;/a&gt;\"\"\" # 匹配符合正则内容 return re.findall(res, result.text)# 解析详情页数据def two_result(contents): for con in contents: # 去第详情页,获取清晰度比较高的图片 result2 = session.get('http://pic.netbian.com/' + con) result2.encoding = 'gbk' res2 = \"\"\"&lt;a href=\"\" id=\"img\"&gt;&lt;img src=\"(.*?)\" data-pic=\".*?\" alt=\"(.*?)\" title=\".*?\"&gt;&lt;/a&gt;\"\"\" # 匹配符合正则内容 contents2 = re.findall(res2, result2.text) # 真正处理数据并保存 save_result(contents2)# 真正处理数据并保存def save_result(contents2): for con2 in contents2: path = con2[0] # 图片真正的高清图片地址 name = con2[1] # 图片名称 # 拼接最后的图片地址,然后保存 result3 = session.get('http://pic.netbian.com/' + path) file = 'D:\\download\\dongmanThreadImg\\%s.jpg' % name # wb : 以二进制格式打开一个文件只用于写入。一般用于非文本文件如图片等。 with open(file, 'wb') as f: f.write(result3.content) # 安全点就等待0.5秒再次爬取 time.sleep(0.5)# 创建线程类class myThread(threading.Thread): def __init__(self, threadID, name, url): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.url = url def run(self): print(\"开始线程：\" + self.name) try: # 得到网页响应结果 result = get_result(self.url) # 处理详情页数据 two_result(result) except Exception: print('线程出现意外....' + self.name) print(\"退出线程：\" + self.name)if __name__ == '__main__': print('下载动漫图片开始--------------') # 爬取前一百页内容 pageno = 100 # 1.请求网页,获取结果 for i in range(1, pageno): print('解析处理第%d页数据 请稍等...' % i) # 第一个和其他页有点不同,所以分开处理 url = '' if i == 1: url = \"http://pic.netbian.com/4kdongman/index.html\" else: url = \"http://pic.netbian.com/4kdongman/index_%d.html\" % i # 开启线程,爬取几页就开启几个线程,量力而行 myThread(i, \"thread-\" + str(i), url).start() # 每次请求间隔0.5秒 time.sleep(0.5)print('下载动漫图片结束--------------') 秒开100线程,每个线程独自爬取,这还没反应过来, 就结束了,我只能说好快 提示:最好还是把代码try 一下, 如果中间有意外,可以忽略,","categories":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/tags/Python/"}]},{"title":"Python的第一个web项目","slug":"20200403-2","date":"2020-04-03T13:15:12.000Z","updated":"2020-04-03T13:31:24.814Z","comments":true,"path":"2020/20200403-2/","link":"","permalink":"https://gmaya.top/2020/20200403-2/","excerpt":"","text":"前言来一个hello python 吧 创建项目项目名称: pythonwebdemo应用名称: webdemo 完成之后,二话不多说,启动!!! 然后点击默认地址 ,访问 成功! hello页面urls.py 文件修改页面请求hello路径, 找到views中的hello接口 12345678from django.contrib import adminfrom django.urls import pathfrom webdemo import viewsurlpatterns = [ path('admin/', admin.site.urls), path(r'hello/', views.hello)] views.py 文件修改 1234567from django.shortcuts import render# Create your views here.# 将请求定位到hello.html中def hello(request): return render(request, 'hello.html') templates 文件夹下新增hello.heml页面 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello Pyhton!!!&lt;/h1&gt;&lt;h2&gt;Hello Pyhton!!!&lt;/h2&gt;&lt;h3&gt;Hello Pyhton!!!&lt;/h3&gt;&lt;h4&gt;Hello Pyhton!!!&lt;/h4&gt;&lt;h5&gt;Hello Pyhton!!!&lt;/h5&gt;&lt;/body&gt;&lt;/html&gt; 启动,访问http://127.0.0.1:8000/hello/ 加上数据库操作settings.py 文件修改数据库默认的sqlite,其实这个数据库也不错,简单的保存也不需要密码啥的,就是性能不中当初在写epl插件的时候,一般都是使用的sqlite,客户不需要安装数据库,直接本地生成了一个.db文件,简单了好多 下面时区和语言在下面搜索一下即可 1234567891011121314DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'python', 'USER': 'root', 'PASSWORD': 'root', 'HOST': '127.0.0.1', 'PORT': 3306 &#125;&#125;LANGUAGE_CODE = 'zh-hans'TIME_ZONE = 'Asia/Shanghai' urls.py 文件修改 1path(r'helloMysql/', views.helloMysql) views.py 文件修改简简单单来个返回结果封装 12345678910def helloMysql(request): data = &#123;&#125; # '-createtime' 前面加-为倒序 userList = models.User.objects.all().order_by('-createtime').values() data['code'] = 200 # 方式一 # data['result'] = json.loads(serializers.serialize('json', userList)) # 方式二 data['result'] = list(userList) return JsonResponse(data, safe=False, json_dumps_params=&#123;'ensure_ascii': False&#125;) 项目路径找到models.py,修改 12345678910111213from django.db import models# Create your models here.class User(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=32) age = models.IntegerField() sex = models.IntegerField() createtime = models.DateTimeField() # 指定数据库表名称 class Meta(): db_table = \"tb_user\" 启动!!! 访问 http://127.0.0.1:8000/helloMysql/查看结果","categories":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/tags/Python/"}]},{"title":"Python连接Mysql数据库Demo","slug":"20200403","date":"2020-04-03T05:29:41.000Z","updated":"2020-04-03T06:50:02.716Z","comments":true,"path":"2020/20200403/","link":"","permalink":"https://gmaya.top/2020/20200403/","excerpt":"","text":"前言这个必须要了解一下,老保存到本地根本不是办法简单的查询,新增,先了解基本写法 创建数据库就算使用java也不会在代码创建数据库啥啥的,所以这里都不去了解怎么在代码创建数据库,表之类的直接手动去创建 123456789DROP TABLE IF EXISTS `tb_user`;CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '名字', `age` int(3) NULL DEFAULT NULL COMMENT '年龄', `sex` int(1) NULL DEFAULT 0 COMMENT '性别,0未知,1男,2女', `createtime` datetime NOT NULL COMMENT '创建时间', PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户测试表' ROW_FORMAT = Compact; 简简单单搞点数据 1234INSERT INTO `tb_user` VALUES (1, '张三', 12, 1, '2020-04-03 11:03:03');INSERT INTO `tb_user` VALUES (2, '李四', 34, 0, '2020-04-03 11:03:13');INSERT INTO `tb_user` VALUES (3, '王五', 45, 2, '2020-04-03 11:03:24');INSERT INTO `tb_user` VALUES (5, '小红', 12, 1, '2020-04-03 13:39:44'); 编写代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# @Author: GMayaimport pymysqlimport datetime# 打开数据库连接db = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='root', db='python', charset='utf8')# 查询方法def seleteUser(): # 使用cursor方法创建一个游标 cursor = db.cursor() sql = \"select * from tb_user\" cursor.execute(sql) data = cursor.fetchall() for d in data: id = d[0] name = d[1] age = d[2] sex = d[3] createtime = d[4] print(id, name, age, sex, createtime) cursor.close() db.close() return datadef insertUser(name, age, sex, createTime): # 使用cursor方法创建一个游标 cursor = db.cursor() sql = \"insert into tb_user(name,age,sex,createtime) values (%s,%s,%s,%s) \" try: # 执行sql语句;使用构造参数防止sql注入! row = cursor.execute(sql, (name, age, sex, createTime)) print(\"影响条数:%s\" % row) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() # 关闭 cursor.close() db.close()if __name__ == '__main__': # 查询 # data = seleteUser() # 新增 insertUser('小红', 12, 1, datetime.datetime.now()) 总结datetime 模块 获取当前时间年月日时分秒now(…)：返回当前日期时间的datetime对象 1datetime.datetime.now() pymysql模块获取新增主键id 1cursor.lastrowid 获取查询全部结果 1cursor.fetchall() 获取查询结果第一条 1cursor.fetchone()","categories":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/tags/Python/"}]},{"title":"Python爬取全球疫情Demo","slug":"20200402-2","date":"2020-04-02T14:09:11.000Z","updated":"2020-04-02T14:13:05.088Z","comments":true,"path":"2020/20200402-2/","link":"","permalink":"https://gmaya.top/2020/20200402-2/","excerpt":"","text":"前言仅仅学习而已,不做其他非法操作.习惯用小demo来熟练各种方法与技巧 分析进入腾讯新闻找到疫情入口https://news.qq.com/zt2020/page/feiyan.htm#/global然后F12分析接口.这对于java老鸟来说,分分钟找到. 1https://api.inews.qq.com/newsqa/v1/automation/foreign/country/ranklist 然后分析json,取什么值, 用什么. 撸代码装工具由于是从0开始学的python,所以什么也没有,只有一个python环境,所以直接来到jb家jetbrains,撸一个pycharm, 用过idea的都知道,直接和idea安装方式一样,一毛一样!!! hello进来不多说, 一个hello例子必须要有 12# @Author: GMayaprint('hello word!') 右键执行 导包想要访问互联网, 你不得一个requests请求么?刚好,导入这个在python安装目录 –&gt; Scripts 包下,进入cmd输入 1pip install requests 等待安装完成!然后在ide里面设置引入 访问接口123456789# @Author: GMayaimport requests# 创建会话对象session = requests.session()# 请求接口result = session.get('https://api.inews.qq.com/newsqa/v1/automation/foreign/country/ranklist')# 打印结果print(result.text) 握草,真是方便快捷狠啊 走一步学一部,看下这个requests包是啥 Requests为Python处理了所有HTTP/1.1操作， 与Web服务的无缝集成。不需要为URL手动添加查询字符串或POST数据进行表单处理。基于urllib3, 能自动处理Keep-alive和HTTP连接池。 此处 自行百度学习了小半个小时,以后用到复杂的再说. 处理结果12345678910111213141516171819# @Author: GMayaimport requests, json, jsonpath# 创建会话对象session = requests.session()# 请求接口result = session.get('https://api.inews.qq.com/newsqa/v1/automation/foreign/country/ranklist')# 打印结果print(result.text)# 解析json结果resJson = json.loads(result.text)data = jsonpath.jsonpath(resJson, '$.data.*')for d in data: res = '日期:' + d['date'] + '--' + d['continent'] + '--' + d['name'] + '--' + '新增确诊:' + str( d['confirmAdd']) + '累计确诊:' + str(d['confirm']) + '治愈:' + str(d['heal']) + '死亡:' + str(d['dead']) # 保存数据到我的d盘 file = 'D:\\download\\global-yq.txt' with open(file, 'a+',encoding='utf-8') as f: f.write(res + '\\n') # 加\\n换行显示 结果已经保存到本地文本里面了.有不懂的命令直接文档里面找,还是很容易的文档连接","categories":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/tags/Python/"}]},{"title":"Python你好!","slug":"20200402","date":"2020-04-02T11:32:11.000Z","updated":"2020-04-02T14:08:49.179Z","comments":true,"path":"2020/20200402/","link":"","permalink":"https://gmaya.top/2020/20200402/","excerpt":"","text":"前言这年头,谁不是熟悉好几个语言!HTML是不是语言! 超文本标记语言&lt;/邪笑&gt; 下载百度搜索Python进入官网https://www.python.org/ 安装双击打开安装包, 注意选择第二个,自定义安装, 谁吧我的软件安装到c盘,我跟谁急下面还有一个add python 勾上! 这样就不需要配置环境变量了.其他的都默认,go!完成! 测试cmd进入,输入python输入 1print(\"hello python!!\") 退出按ctrl+z,回车","categories":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://gmaya.top/tags/Python/"}]},{"title":"定时任务@Scheduled入门","slug":"20200330","date":"2020-03-30T06:12:11.000Z","updated":"2020-03-30T08:30:07.249Z","comments":true,"path":"2020/20200330/","link":"","permalink":"https://gmaya.top/2020/20200330/","excerpt":"","text":"一个最简单的例子:启动类添加注解 1@EnableScheduling // 开启定时任务 编写单线程demo cron 表达式1234567891011/** * cron 表达式 * 每2秒执行一次 * @throws InterruptedException */ @Scheduled(cron = \"0/2 * * * * *\") public void test() throws InterruptedException &#123; // 经过测试,使用cron表达式,定时任务第二次会等待第一次执行完毕再开始! Thread.sleep(5000L); log.info(\"定时任务测试cron:\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); &#125; fixedDelay12345678910/** * fixedDelay: * 第一次执行完毕才会执行第二次，时间间隔变为了7秒 * @throws InterruptedException */ @Scheduled(fixedDelay = 2000L) public void test2() throws InterruptedException &#123; Thread.sleep(5000L); log.info(\"定时任务测试fixedDelay:\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); &#125; fixedRate12345678910/** * fixedRate: * 每隔2秒就会执行, 但是因为单线程,所以在5秒后会输出,间隔就是5秒 * @throws InterruptedException */ @Scheduled(fixedRate = 2000L) public void test3() throws InterruptedException &#123; Thread.sleep(5000L); log.info(\"定时任务测试fixedRate:\" + new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); &#125; 如果是一起执行这三个定时任务,那么会一个一个的来, 因为只有一个线程. 多线程1234567891011121314/** * * @author GMaya */@Configuration@EnableAsyncpublic class ScheduleConfig &#123; @Bean public TaskScheduler taskScheduler() &#123; ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler(); taskScheduler.setPoolSize(50); // 设置线程池大小 return taskScheduler; &#125;&#125; 如果只是加这一个配置类, 确实是使用了多线程, 每个定时任务都互相不影响.但是一个线程第一次阻塞了,第二次就不行了,所以在定时任务上再加 1@Async 就是说你这次失败了, 不要影响我下次的运行","categories":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/categories/Java/"}],"tags":[{"name":"定时任务","slug":"定时任务","permalink":"https://gmaya.top/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"Spring Cloud 整合最新版seata分布式事务 (六)","slug":"20200327-2","date":"2020-03-27T07:12:11.000Z","updated":"2020-03-27T07:00:05.949Z","comments":true,"path":"2020/20200327-2/","link":"","permalink":"https://gmaya.top/2020/20200327-2/","excerpt":"","text":"前言现在我有 订单系统, 支付系统.注册中心每个系统都是单独的,事务也都是本地事务,也是独立的.那么问题来了.我—&gt;订单系统–&gt;支付系统.–&gt;订单系统—&gt;我支付系统成功了 ,自己的事务也提交了.到订单系统结果失败了.(结果就是钱付了,订单还未支付.)这样就存在了问题呀.更多的问题也存在库存系统,加库存,改订单状态,支付等等,每个单独的模块事务怎么保持统一呢!! seata 介绍 Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案. seata各种官方例子连接:https://github.com/seata/seata-samplesseata服务端下载链接:https://github.com/seata/seata/releases 根据例子,我搞了好久好久好久好久好久才把例子跑起来.我也是服了,中间各种问题,网上的答案都尼玛一模一样!,人家都能成功,我就失败.郁闷死了. 思路1.下载官方的服务端seata-server2.下载官方客户端例子(我选的是springcloud-eureka-feign-mybatis-seata)3.修改配置.4.启动.5.哪里错改哪里!前4步也就半个小时,顶多俩小时,ok了.第5步鬼知道多长时间. 我结合官方demo,整合到自己的项目中去.以及中间遇到的问题记录 seata服务端下载seata服务端seata服务端下载链接:https://github.com/seata/seata/releases我选的是最新的v1.1.0版本,下载到本地即可 修改seata配置我这里就说win下怎么启动:首先修改目录下的conf中的配置file.conf其中我没有使用db方式, 使用的默认file方式,应该不需要修改 12345678910111213141516171819202122232425262728293031323334353637383940## transaction log store, only used in seata-serverstore &#123; ## store mode: file、db mode = \"file\" ## file store property file &#123; ## store location dir dir = \"sessionStore\" # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions maxBranchSessionSize = 16384 # globe session size , if exceeded throws exceptions maxGlobalSessionSize = 512 # file buffer size , if exceeded allocate new buffer fileWriteBufferCacheSize = 16384 # when recover batch read size sessionReloadReadSize = 100 # async, sync flushDiskMode = async &#125; ## database store property db &#123; ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = \"dbcp\" ## mysql/oracle/h2/oceanbase etc. dbType = \"mysql\" driverClassName = \"com.mysql.jdbc.Driver\" url = \"jdbc:mysql://127.0.0.1:3306/seata\" user = \"mysql\" password = \"mysql\" minConn = 1 maxConn = 10 globalTable = \"global_table\" branchTable = \"branch_table\" lockTable = \"lock_table\" queryLimit = 100 &#125;&#125; registry.conf我使用的类型是eureka,配置上之前的注册中心地址 1234567891011121314151617registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = \"eureka\" eureka &#123; serviceUrl = \"http://server01:8761/eureka/\" application = \"default\" weight = \"1\" &#125;&#125;config &#123; # file、nacos 、apollo、zk、consul、etcd3 type = \"file\" file &#123; name = \"file.conf\" &#125;&#125; 启动seata服务端修改完毕,首先启动你的注册中心eureka,然后启动这个seata服务端首先进入bin目录seata-server.bat 这个是win命令,在这个目录进入cmd, 将这个文件拖进窗口,输入 1-h 127.0.0.1 -p 8091 -m file 最终效果:脚本参数:-p:指定启动seata server的端口号。-h:指定seata server所绑定的主机-m:指定事务日志、事务执行信息存储的方式，目前支持file（文件方式）、db（数据库方式) 这个地方我遇到的问题:第一个:我没有指定主机,然后和后面的配置里面对应不上,显示连接不上seata server服务. 导入jar123456&lt;!--seata--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-seata&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 修改自己项目的配置新增两个配置文件,每个模块里面都需要,先修改一个,然后拷贝过去就行了 file.conf 文件其中大部分是默认的,只需要修改一个地方 12345678910service &#123; #transaction service group mapping vgroup_mapping.tx = \"default\" #only support when registry.type=file, please don't set multiple addresses default.grouplist = \"127.0.0.1:8091\" #degrade, current not support enableDegrade = false #disable seata disableGlobalTransaction = false&#125; 注意,这个tx这个名字可以自己改,但是application.yml中一定要与之对应,往下看 完整的file.conf 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566transport &#123; # tcp udt unix-domain-socket type = \"TCP\" #NIO NATIVE server = \"NIO\" #enable heartbeat heartbeat = true # the client batch send request enable enableClientBatchSendRequest = true #thread factory for netty threadFactory &#123; bossThreadPrefix = \"NettyBoss\" workerThreadPrefix = \"NettyServerNIOWorker\" serverExecutorThread-prefix = \"NettyServerBizHandler\" shareBossWorker = false clientSelectorThreadPrefix = \"NettyClientSelector\" clientSelectorThreadSize = 1 clientWorkerThreadPrefix = \"NettyClientWorkerThread\" # netty boss thread size,will not be used for UDT bossThreadSize = 1 #auto default pin or 8 workerThreadSize = \"default\" &#125; shutdown &#123; # when destroy server, wait seconds wait = 3 &#125; serialization = \"seata\" compressor = \"none\"&#125;service &#123; #transaction service group mapping vgroup_mapping.tx = \"default\" #only support when registry.type=file, please don't set multiple addresses default.grouplist = \"127.0.0.1:8091\" #degrade, current not support enableDegrade = false #disable seata disableGlobalTransaction = false&#125;client &#123; rm &#123; asyncCommitBufferLimit = 10000 lock &#123; retryInterval = 10 retryTimes = 30 retryPolicyBranchRollbackOnConflict = true &#125; reportRetryCount = 5 tableMetaCheckEnable = false reportSuccessEnable = false &#125; tm &#123; commitRetryCount = 5 rollbackRetryCount = 5 &#125; undo &#123; dataValidation = true logSerialization = \"jackson\" logTable = \"undo_log\" &#125; log &#123; exceptionRate = 100 &#125;&#125; registry.conf文件注册选择type = eureka,然后配置eureka地址即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = \"eureka\" nacos &#123; serverAddr = \"localhost\" namespace = \"\" cluster = \"default\" &#125; eureka &#123; serviceUrl = \"http://server01:8761/eureka/\" application = \"default\" weight = \"1\" &#125; redis &#123; serverAddr = \"localhost:6379\" db = \"0\" password = \"\" cluster = \"default\" timeout = \"0\" &#125; zk &#123; cluster = \"default\" serverAddr = \"127.0.0.1:2181\" session.timeout = 6000 connect.timeout = 2000 username = \"\" password = \"\" &#125; consul &#123; cluster = \"default\" serverAddr = \"127.0.0.1:8500\" &#125; etcd3 &#123; cluster = \"default\" serverAddr = \"http://localhost:2379\" &#125; sofa &#123; serverAddr = \"127.0.0.1:9603\" application = \"default\" region = \"DEFAULT_ZONE\" datacenter = \"DefaultDataCenter\" cluster = \"default\" group = \"SEATA_GROUP\" addressWaitTime = \"3000\" &#125; file &#123; name = \"file.conf\" &#125;&#125;config &#123; # file、nacos 、apollo、zk、consul、etcd3、springCloudConfig type = \"file\" nacos &#123; serverAddr = \"localhost\" namespace = \"\" group = \"SEATA_GROUP\" &#125; consul &#123; serverAddr = \"127.0.0.1:8500\" &#125; apollo &#123; app.id = \"seata-server\" apollo.meta = \"http://192.168.1.204:8801\" namespace = \"application\" &#125; zk &#123; serverAddr = \"127.0.0.1:2181\" session.timeout = 6000 connect.timeout = 2000 username = \"\" password = \"\" &#125; etcd3 &#123; serverAddr = \"http://localhost:2379\" &#125; file &#123; name = \"file.conf\" &#125;&#125; 修改application.yml第一个方式:注意,这个tx-service-group: 后面的tx一定要和上面配置中的tx一样.一定一定要一样 12345spring: cloud: alibaba: seata: tx-service-group: tx 第二个方式: application.yml这个文件不指定tx-service-group,那么file.conf这个文件的vgroup_mapping.tx就必须修改为seata默认的形式在这个源码中可以看到,如果你没有定义,那么你这个file.conf配置中必须设置为applicationName + “-fescar-service-group”举例:我这个项目就必须设置为order-fescar-service-group 123spring: application: name: order 都是坑踩出来的………….. 新增数据源配置一开始我最下面的mybatis的配置没有注释,就会发生添加语句执行找不到mapper注释掉就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.gmaya.order.config;import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import javax.sql.DataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;/** * 数据源代理 * @author GMaya */@Configurationpublic class DataSourceConfiguration &#123; @Bean @ConfigurationProperties(prefix = \"spring.datasource\") public DataSource druidDataSource()&#123; DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; &#125; @Primary @Bean(\"dataSource\") public DataSourceProxy dataSource(DataSource druidDataSource)&#123; return new DataSourceProxy(druidDataSource); &#125; /* @Bean public SqlSessionFactory sqlSessionFactory(DataSourceProxy dataSourceProxy)throws Exception&#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(\"classpath*:/mapper/*.xml\")); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125;*/&#125; 修改启动类1@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) 修改完将以上操作在pay中复制. 数据库新增表因为我是模拟的, 所以,只要是操作数据库就行了,就没弄多个库,在一个数据库,一个表tb_user此时在加一个seata需要的表undo_log 1234567891011121314151617181920212223-- ------------------------------ Table structure for undo_log-- ----------------------------DROP TABLE IF EXISTS `undo_log`;CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `ux_undo_log`(`xid`, `branch_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- ------------------------------ Records of undo_log-- ----------------------------SET FOREIGN_KEY_CHECKS = 1; 测试order中调用pay创建一条数据,然后自己在创建一条语句.在order方法上加上注解 1@GlobalTransactional 启动order 启动pay,测试! pay日志:添加数据成功没错,但是结果回滚了order日志:最终数据库还是没有添加进去 再测:调用订单–&gt;先本地添加数据, 然后在调用支付,让支付失败,看订单是否回滚测试结果还是回滚.自己一步一步一步一步敲出来的,希望我下次不要遇到这些问题.","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://gmaya.top/tags/Eureka/"},{"name":"seata","slug":"seata","permalink":"https://gmaya.top/tags/seata/"}]},{"title":"Spring Cloud 整合mybatis-plus (五)","slug":"20200327","date":"2020-03-27T04:26:43.000Z","updated":"2020-03-27T06:53:27.015Z","comments":true,"path":"2020/20200327/","link":"","permalink":"https://gmaya.top/2020/20200327/","excerpt":"","text":"前言其实这个整合,和spring 或者 spring boot 整合一样的其实都是一键生成的,自己把模板配好就行,从controller到service,dao,实体,增删改查我只是拷贝过来几个测试这个项目之前刚接触mybatis-plus的时候也写过自动生成的文章 引入jar1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.7.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件我mysql数据库8.0以上的,如果你的是5.+的版本,自己该数据源即可 1234567891011121314151617181920spring: application: name: order datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/gmaya?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 username: root password: admin#mybatis-plusmybatis-plus: mapper-locations: classpath:/mapper/*.xml typeAliasesPackage: com.gmaya.order.entity global-config: db-config: id-type: AUTO field-strategy: NOT_NULL column-underline: true logic-delete-value: 1 # 数据库删除字段,1代表删除 logic-not-delete-value: 0 # 0代表没删除 banner: false 新增配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.gmaya.order.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.baomidou.mybatisplus.core.injector.ISqlInjector;import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;/** * mybatis-plus配置 * * @author GMaya */@Configurationpublic class MybatisPlusConfig &#123; /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125; /** * 控制逻辑删除 * @return */ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125; /** * 控制版本号 * @return */ @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125;&#125; 实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.gmaya.order.entity;import java.io.Serializable;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableLogic;import com.baomidou.mybatisplus.annotation.TableName;import com.baomidou.mybatisplus.annotation.Version;import lombok.Data;/** * DO * * @author GMaya */@Data@TableName(\"tb_user\")public class UserEntity implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 用户id */ @TableId(value = \"id\") private Integer id; /** * 用户名称 */ private String name; /** * 用户年龄 */ private Integer age; /** * 是否删除。0未删除，1删除 */ @TableLogic private Integer isDtl; /** * 版本号 */ @Version private Integer version;&#125; dao1234567891011package com.gmaya.order.dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.gmaya.order.entity.UserEntity;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Component;@Mapperpublic interface UserDao extends BaseMapper&lt;UserEntity&gt; &#123;&#125; service1234567891011121314package com.gmaya.order.service;import com.alibaba.fastjson.JSONObject;import com.baomidou.mybatisplus.extension.service.IService;import com.gmaya.order.entity.UserEntity;/** * 服务类 * @author GMaya */public interface UserService extends IService&lt;UserEntity&gt; &#123; int add(JSONObject jsonObject);&#125; impl12345678910111213141516171819202122232425262728293031323334353637package com.gmaya.order.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.gmaya.order.dao.UserDao;import com.gmaya.order.entity.UserEntity;import com.gmaya.order.service.UserService;import lombok.extern.slf4j.Slf4j;/** * * @author GMaya */@Service(\"userService\")@Slf4jpublic class UserServiceImpl extends ServiceImpl&lt;UserDao, UserEntity&gt; implements UserService &#123; @Override public int add(JSONObject jsonObject) &#123; log.info(\"log...订单开始......\"); UserEntity userEntity = new UserEntity(); userEntity.setAge(1); userEntity.setIsDtl(0); userEntity.setVersion(1); userEntity.setName(\"订单模拟\"); int insert = baseMapper.insert(userEntity); log.info(\"log...订单结束......\"); return insert; &#125;&#125;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/tags/SpringCloud/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://gmaya.top/tags/mybatis-plus/"}]},{"title":"使用redis实现序列号工具类","slug":"20200323","date":"2020-03-23T10:43:11.000Z","updated":"2020-03-23T10:46:54.896Z","comments":true,"path":"2020/20200323/","link":"","permalink":"https://gmaya.top/2020/20200323/","excerpt":"","text":"前言项目中难免会带有字符的序列号,有的是每月从1开始, 有的是每天等等.以前也使用过存表的方式,每次获取之后加1.这次又了解了一个.记录一下redis为单线程，不存在线程安全问题. 序列号工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.gmaya.EurekaClient.util;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.TimeUnit;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.support.atomic.RedisAtomicLong;import org.springframework.stereotype.Service;/** * 序列号工具类 * @author GMaya */@Servicepublic class SequenceUtil &#123; @Autowired private RedisTemplate redisTemplate; /** * 获取序列号 * 例子：假如需要获取订单号NO20200320000001等数据，前缀NO，后面的每天从1开始自增 * 调用getCode(\"NO\") 返回 202003200000001,0的个数根据自己业务量设置 * 自己将返回的字符串再次拼接上NO即可！序列号 = 'NO'+getCode(\"NO\") * @param keyPrefix 关键词前缀 * @return 序列号 */ public String getCode(String keyPrefix) &#123; // 当前日期加填充完0的值 return new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + getSequence(keyPrefix); &#125; /** * 根据关键词前缀设置redis的key * @param keyPrefix * @return */ private String getSequence(String keyPrefix) &#123; // 如果你的序列号需要每个月从1开始计算，那么时间就变为yyyyMM。 String currentDate = new SimpleDateFormat(\"yyyyMMdd\").format(new Date()); // 得到这个key的value值 Long num = getIncrementNum(\"seq:\" + keyPrefix + currentDate); // 填充这个值，一般情况下一天的序列号3位差不多，所以前面几位需要填充0 return getSequence(num); &#125; /** * 查询redis中这个key，并且加1返回 * @param key * @return */ private Long getIncrementNum(String key) &#123; // 不存在准备创建 键值对 RedisAtomicLong entityIdCounter = new RedisAtomicLong(key, redisTemplate.getConnectionFactory()); Long counter = entityIdCounter.incrementAndGet(); // 自增加1 if ((null == counter || counter.longValue() == 1)) &#123; // 初始设置过期时间 entityIdCounter.expire(2, TimeUnit.DAYS);// 单位天 &#125; return counter; &#125; static final int DEFAULT_LENGTH = 8; // 填充0的总位数 /** * 将数值前面填充0 * @param seq * @return */ private static String getSequence(long seq) &#123; String str = String.valueOf(seq); int len = str.length(); // 一般业务量不会超过8位数 if (len &gt;= DEFAULT_LENGTH) &#123; return str; &#125; // 前面填充0，保证数值一直是8位数 int rest = DEFAULT_LENGTH - len; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; rest; i++) &#123; sb.append('0'); &#125; sb.append(str); return sb.toString(); &#125;&#125; 测试 1234567891011121314151617181920212223242526package com.gmaya.EurekaClient;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import com.gmaya.EurekaClient.util.SequenceUtil;@SpringBootTestclass EurekaClientApplicationTests &#123; @Autowired private SequenceUtil sequenceUtil; @Test public void getCode() &#123; String no = \"NO\" + sequenceUtil.getCode(\"NO\"); String no2 = \"NO\" + sequenceUtil.getCode(\"NO\"); String no3 = \"NO\" + sequenceUtil.getCode(\"NO\"); String no4 = \"NO\" + sequenceUtil.getCode(\"NO\"); System.out.println(no); System.out.println(no2); System.out.println(no3); System.out.println(no4); &#125;&#125; 结果: 1234NO2020032300000005NO2020032300000006NO2020032300000007NO2020032300000008","categories":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/categories/Java/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://gmaya.top/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"redis","slug":"redis","permalink":"https://gmaya.top/tags/redis/"}]},{"title":"分享一下uTools工具","slug":"20200321","date":"2020-03-21T07:22:11.000Z","updated":"2020-03-21T07:24:00.396Z","comments":true,"path":"2020/20200321/","link":"","permalink":"https://gmaya.top/2020/20200321/","excerpt":"","text":"持续加班ing..分享 一个自己正在使用的工具uTools你的生产力工具集 uTools是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。 具体优点自己体会吧.","categories":[{"name":"工具","slug":"工具","permalink":"https://gmaya.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://gmaya.top/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"IDEA常用插件","slug":"20200319","date":"2020-03-19T14:32:11.000Z","updated":"2020-03-19T14:32:56.531Z","comments":true,"path":"2020/20200319/","link":"","permalink":"https://gmaya.top/2020/20200319/","excerpt":"","text":"分享自己平时常用的idea插件 1.Mybatis Log Plugin 功能:把 mybatis 输出的sql日志还原成完整的sql语句。 将日志输出的sql语句中的问号 ? 替换成真正的参数值 直接在软件Plugins中下载即可,注意下载完要重启idea 在Tools中点击 即可进入 2.Rainbow Brackets 功能:彩虹方括号 让你的括号变得魔力转圈圈 3.Free Mybatis plugin 功能:在serviceImpl直接去到mapper.xml中的该方法 选中方法名,快捷键Ctrl + T","categories":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/categories/Java/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://gmaya.top/tags/idea/"},{"name":"插件","slug":"插件","permalink":"https://gmaya.top/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"Spring Cloud Hystrix断路器（四）","slug":"20200318","date":"2020-03-18T04:54:16.000Z","updated":"2020-03-18T02:59:06.530Z","comments":true,"path":"2020/20200318/","link":"","permalink":"https://gmaya.top/2020/20200318/","excerpt":"","text":"前言 在微服务场景中，通常会有很多层的服务调用。如果一个底层服务出现问题，故障会被向上传播给用户。我们需要一种机制，当底层服务不可用时，可以阻断故障的传播。这就是断路器的作用。他是系统服务稳定性的最后一重保障。 常常会遇到正在使用某个系统，点击到某一个功能的时候显示该模块正在升级或者请稍后查看等。怎么实现呢？？ 使用Feign整合Hystrix默认是不开启的，需要修改配置文件application.yml，添加下面的代码 1234feign: hystrix: #开启Hystrix熔断，默认false enabled: true 新增支付模块熔断器 123456789101112/** * @ Description : 支付模块熔断器 * @ Author : GMaya * @ CreateDate : 2020/3/18 9:35 * @ Version : 1.0 */@Componentpublic class PayClientFallBack implements PayClient &#123; @Override public String getPay() &#123; return \"支付模块正在抢修，请稍后！\" +\" :feign演示\"; &#125;&#125; 修改PayClient接口 1@FeignClient(name = \"pay\",fallback = PayClientFallBack.class) // 服务名称 启动服务端，启动pay客户端，启动order客户端。访问http://localhost:8082/getOrder然后把pay客户端关掉！ 使用RestTemplat整合Hystrixpom添加j依赖 12345&lt;!--熔断器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 启动类新增注解 1@EnableCircuitBreaker 或者 @SpringBootApplication+@EnableDiscoveryClient+@EnableCircuitBreaker也可以使用@SpringCloudApplication 一个顶替仨 SpringCloudApplication注解 源码： 修改订单接口 123456789101112131415161718192021222324252627/** * @ Description : 订单接口接口 * @ Author : GMaya * @ CreateDate : 2020/3/16 11:03 * @ Version : 1.0 */@RestControllerpublic class OrderController &#123;// @Autowired// private PayClient payClient; // 注入支付模块服务 @Autowired private RestTemplate restTemplate; @RequestMapping(\"/getOrder\") @HystrixCommand(fallbackMethod = \"getRestTemplateFallBack\") public String getOrder()&#123; String pay = restTemplate.getForObject(\"http://pay/getPay\", String.class); // String pay = payClient.getPay(); return pay; &#125; private String getRestTemplateFallBack()&#123; return \"不好啦，机房着火了，restTemplate演示！\"; &#125;&#125; 当然，当接口多的时候，还可以改造 123456789101112131415161718192021222324252627282930313233/** * @ Description : 订单接口接口 * @ Author : GMaya * @ CreateDate : 2020/3/16 11:03 * @ Version : 1.0 */@RestController@DefaultProperties(defaultFallback = \"defaultFallback\")public class OrderController &#123;// @Autowired// private PayClient payClient; // 注入支付模块服务 @Autowired private RestTemplate restTemplate; @RequestMapping(\"/getOrder\")// @HystrixCommand(fallbackMethod = \"getRestTemplateFallBack\") @HystrixCommand // 使用默认熔断，加一个注解就行 public String getOrder()&#123; String pay = restTemplate.getForObject(\"http://pay/getPay\", String.class); // String pay = payClient.getPay(); return pay; &#125; private String getRestTemplateFallBack()&#123; return \"不好啦，机房着火了，restTemplate演示！\"; &#125; private String defaultFallback()&#123; return \"默认熔断！\"; &#125;&#125; 重启查看 最后：额外配置，如需更多，请查看专业解释 如果设置和默认值一样，没必要写出来配置 123456789101112131415161718feign: hystrix: #开启Hystrix熔断，默认false enabled: truehystrix: command: # 全局设置 default: execution: isolation: # 命令执行超时时间，默认1000ms，只在线程池隔离中有效。 thread: timeoutInMilliseconds: 1000 # 发生超时是是否中断，默认true，只在线程池隔离中有效。 interruptOnTimeout: true # 执行是否启用超时，默认启用true，只在线程池隔离中有效。 timeout: enabled: true","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/tags/SpringCloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://gmaya.top/tags/Hystrix/"}]},{"title":"Short 类型直接和数值1做对比","slug":"20200317","date":"2020-03-17T04:34:16.000Z","updated":"2020-03-17T08:55:47.111Z","comments":true,"path":"2020/20200317/","link":"","permalink":"https://gmaya.top/2020/20200317/","excerpt":"","text":"今天写项目遇到了Short 返回1 需要做个判断，所以就多想了一下，研究了一下大声的告诉我，是true还是true还是true！！！ 12345public static void main(String[] args) &#123; Short a = 1; System.out.println(a.equals(1)); System.out.println(a==1);&#125; 一开始觉得包装类型用==和equals应该都可以的，但是结果却是，false，true。第二个就不说了，都知道。所以就研究了一下第一个equals扒拉源码！ctrl + o 找到equals 方法！ 12345678910111213141516/** * Compares this object to the specified object. The result is * &#123;@code true&#125; if and only if the argument is not * &#123;@code null&#125; and is a &#123;@code Short&#125; object that * contains the same &#123;@code short&#125; value as this object. * * @param obj the object to compare with * @return &#123;@code true&#125; if the objects are the same; * &#123;@code false&#125; otherwise. */public boolean equals(Object obj) &#123; if (obj instanceof Short) &#123; return value == ((Short)obj).shortValue(); &#125; return false;&#125; 搜嘎，原来不属于Short类型的，就是false那这个直接凭空写的这个1是什么类型啊。有去查了一下java的基本类型默认值，什么四类八种的 1234int初值为0long初值为0Lbyte初值为(byte)0short初值为(short)0 所以1我觉得是int型的 同时又看了一下Short 和Integer一样，都有缓存的Short 12345678910private static class ShortCache &#123; private ShortCache()&#123;&#125; static final Short cache[] = new Short[-(-128) + 127 + 1]; static &#123; for(int i = 0; i &lt; cache.length; i++) cache[i] = new Short((short)(i - 128)); &#125; &#125; Integer 123456789101112131415161718192021222324252627282930313233private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125;","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://gmaya.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/tags/Java/"}]},{"title":"Spring Cloud Eureka服务通信Ribbon/Feign（三）","slug":"20200316-2","date":"2020-03-16T14:12:12.000Z","updated":"2020-03-16T07:21:10.770Z","comments":true,"path":"2020/20200316-2/","link":"","permalink":"https://gmaya.top/2020/20200316-2/","excerpt":"","text":"问题每一个客户端就是一个完整的项目，是一个模块，假如我有订单模块，支付模块，用户模块，等等，那么我这些模块之间怎么相互调用呢？采用HttpClient工具类访问？ Ribbon 和 Feign 简介Ribbon 简介 Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon 客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出 Load Balancer 后面所有的机器，Ribbon 会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。简单地说，Ribbon 是一个客户端负载均衡器。 Feign 简介 Feign 是一个声明式的 web service 客户端，它使得编写 web service 客户端更为容易。创建接口，为接口添加注解，即可使用Feign。Feign可以使用Feign注解或者JAX-RS注解，还支持热插拔的编码器和解码器。Spring Cloud 为Feign添加了Spring MVC的注解支持，并整合了Ribbon和Eureka来为使用 Feign 时提供负载均衡。 创建支付模块（客户端）起名pay项目，也可以去spring官网 https://start.spring.io/按照之前的办法创建再介绍一个方法，直接在idea中创建下一步填写组织和项目名称搜索添加下一步完成然后按照客户端的修改操作进行修改修改application.yml因为是小demo，所以就不使用集群了，电脑有点卡。真实情况每个服务端和客户端有可能都不在一个服务器上 1234567891011spring: application: name: payserver: port: 8081eureka: client: service-url: #注册中心路径，表示我们向这个注册中心注册服务，如果向多个注册中心注册，用“，”进行分隔 #defaultZone: http://server01:8761/eureka/,http://server02:8762/eureka/ defaultZone: http://server01:8761/eureka/ 修改启动项添加注解@EnableDiscoveryClient添加一个正常情况下的最简洁支付接口 123456789101112131415/** * @ Description : 支付接口 * @ Author : GMaya * @ CreateDate : 2020/3/16 10:53 * @ Version : 1.0 */@RestControllerpublic class PayController &#123; @RequestMapping(\"/getPay\") public String getPay()&#123; // 返回支付信息 return \"this pay！！！\"; &#125;&#125; 创建订单模块（客户端）跟上面支付模块一模一样的操作。。。注意：创建订单最简洁订单的接口 123456789101112131415/** * @ Description : 订单接口 * @ Author : GMaya * @ CreateDate : 2020/3/16 11:03 * @ Version : 1.0 */@RestControllerpublic class OrderController &#123; @RequestMapping(\"/getOrder\") public String getOrder()&#123; // 返回订单信息 return \"this order！！！\"; &#125;&#125; 此时两个正常的项目已经创建完毕，那么我订单模块怎么去调用支付模块呢？ 方式一：RestTemplate调用修改订单模块接口 123456@RequestMapping(\"/getOrder\") public String getOrder()&#123; RestTemplate restTemplate = new RestTemplate(); String forObject = restTemplate.getForObject(\"http://localhost:8081/getPay\", String.class); return forObject; &#125; 启动服务端，启动支付端，启动订单端调用支付接口调用订单接口可以看出调用成功，但是缺点也很明显，必须要知道对方的url地址，对于多个实例那就难受了，所以是不可取的。 方式二：通过 @LoadBalanced添加RestTemplateConfig配置 1234567891011121314/** * @ Description : RestTemplate配置类 * @ Author : GMaya * @ CreateDate : 2020/3/16 11:24 * @ Version : 1.0 */@Componentpublic class RestTemplateConfig &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 修改订单接口此时只需要填写调用的项目名就好了，跟ip无关。 123456789101112131415161718/** * @ Description : 订单接口接口 * @ Author : GMaya * @ CreateDate : 2020/3/16 11:03 * @ Version : 1.0 */@RestControllerpublic class OrderController &#123; @Autowired private RestTemplate restTemplate; @RequestMapping(\"/getOrder\") public String getOrder()&#123; String forObject = restTemplate.getForObject(\"http://PAY/getPay\", String.class); return forObject; &#125;&#125; 重启订单项目查看 @LoadBalanced 源码注解源码注释中说，用来标记restTemplate使之配置使用LoadBalancerClient 12345678910111213/** * Annotation to mark a RestTemplate or WebClient bean to be configured to use a * LoadBalancerClient. * @author Spencer Gibb */@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Qualifierpublic @interface LoadBalanced &#123;&#125; LoadBalancerClient则表示客户端负载均衡器。所以使用@LoadBalanced就代表使用ribbon实现客户端的负载均衡负载均衡的策略默认使用的是轮询算法 负载均衡是在同一个功能的微服务中根据不同的策略选择不同的微服务，因此这些微服务对外暴露的实例名称要相同（spring.application.name）ribbon是一个客户端的负载均衡，必须要连接eureka，才能在指定的微服务实例中按照策略选择 假设支付模块（pay）部署在两台或者多台服务器，只有端口号不一样，其他的都一样，那么我订单模块按照轮询算法去调用支付模块。 方式三：通过 Feign第一步：添加Feign依赖打开订单模块pom文件 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 第二步：修改订单模块启动类OrderApplication添加注解@EnableFeignClients第三步：声明需要调用的接口创建PayClient接口 123456789101112/** * @ Description : 支付接口声明 * @ Author : GMaya * @ CreateDate : 2020/3/16 14:28 * @ Version : 1.0 */@FeignClient(name = \"pay\") // 服务名称public interface PayClient &#123; @RequestMapping(\"/getPay\") // 这里要和pay提供的接口一致 String getPay();&#125; 修改OrderController 123456789101112131415161718/** * @ Description : 订单接口接口 * @ Author : GMaya * @ CreateDate : 2020/3/16 11:03 * @ Version : 1.0 */@RestControllerpublic class OrderController &#123; @Autowired private PayClient payClient; // 注入支付模块服务 @RequestMapping(\"/getOrder\") public String getOrder()&#123; String pay = payClient.getPay(); return pay; &#125;&#125; 重启订单模块项目，一切正常！ 只有先入门，才能追查源码以及骚操作！","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://gmaya.top/tags/Eureka/"}]},{"title":"Spring Cloud Eureka高可用的服务注册中心（二）","slug":"20200316","date":"2020-03-16T04:52:12.000Z","updated":"2020-03-16T07:15:59.170Z","comments":true,"path":"2020/20200316/","link":"","permalink":"https://gmaya.top/2020/20200316/","excerpt":"","text":"集群原理图如果只有一个注册中心（服务端），一旦挂掉，就直接GG，在分布式系统中，任何地方存在单点故障，整个系统就不是高可用的。（自己手画的难看见谅） 创建服务端2在上一篇文章中写了最简单的单服务端，单客户端的例子。所以，在上一篇的基础上，继续新建一个服务端，起名字叫做服务端2登录spring官网 https://start.spring.io/保存到本地之后，导入项目服务器2（EurekaServerTwo）启动类添加注解 1@EnableEurekaServer 修改EurekaServerTwo配置文件application.yml 123456789101112131415161718server: port: 8762eureka: client: service-url: # #注册中心路径，表示我们向这个注册中心注册服务，如果向多个注册中心注册，用“，”进行分隔 # 向端口8761注册(两个服务端互相注册) defaultZone: http://server01:8761/eureka/ # 指示此实例是否应将其信息注册到eureka服务器以供其他服务发现，默认为false register-with-eureka: false instance: # 该服务实例所在主机名 hostname: server02 server: # 启用自我保护机制，默认为true enable-self-preservation: falsespring: profiles: server02 修改服务器1EurekaServer修改EurekaServer项目的配置文件application.yml 123456789101112131415161718server: port: 8761eureka: client: service-url: # 注册中心路径，表示我们向这个注册中心注册服务，如果向多个注册中心注册，用“，”进行分隔 # 向端口8762注册(两个服务端互相注册) defaultZone: http://server02:8762/eureka/ # 指示此实例是否应将其信息注册到eureka服务器以供其他服务发现，默认为false register-with-eureka: false instance: # 该服务实例所在主机名 hostname: server01 server: # 启用自我保护机制，默认为true enable-self-preservation: falsespring: profiles: server01 修改电脑hosts文件修改host文件添加对application.yml配置文件中hostname的映射打开电脑C:\\Windows\\System32\\drivers\\etc找到hosts，在文件最后输入 12127.0.0.1 server01127.0.0.1 server02 注意使用管理员权限，不然没办法保存 启动查看效果修改启动配置项在服务器1配置 1-Dspring.profiles.active=server01 在服务器2配置 1-Dspring.profiles.active=server02 启动服务器1，启动服务器2，启动客户端如果在启动中报错，先则是因为服务器1向服务器2注册没有连接上，等你服务器2启动完毕就不会报错了。最终在浏览器查看效果http://localhost:8761/http://localhost:8762/ 停止服务器1此时检验效果，停止服务器1，即端口号为：8761的服务器稍微等待一会，因为有默认的失效时间。查看http://localhost:8762此时客户端已经消失，这是因为客户端没有配置服务器2的注册。 修改客户端修改EurekaClient项目的配置文件application.yml将两个注册中心全部配置上去 12345678910spring: application: name: eureka-clientserver: port: 8711eureka: client: service-url: #注册中心路径，表示我们向这个注册中心注册服务，如果向多个注册中心注册，用“，”进行分隔 defaultZone: http://server01:8761/eureka/,http://server02:8762/eureka/ 将server02注册进来，重新启动服务端1，服务端2，客户端，再次演示上面断掉服务端1的操作这个时候server02就能一直显示客户端的注册 这样就算一个服务器挂掉，对整体也不会有影响了。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://gmaya.top/tags/Eureka/"}]},{"title":"Spring Cloud Eureka最简单的入门（一）","slug":"20200315","date":"2020-03-15T13:33:45.000Z","updated":"2020-03-15T13:53:30.072Z","comments":true,"path":"2020/20200315/","link":"","permalink":"https://gmaya.top/2020/20200315/","excerpt":"","text":"Eureka介绍 Eureka是一个基于REST的服务，主要用于AWS云中的定位服务，以实现中间层服务器的负载平衡和故障转移，在 Spring Cloud 微服务架构中通常用作注册中心，我们称这个服务为 Eureka Server，还有一个与之交互的客户端称之为 Eureka Client 创建eureka服务端登录spring官网 https://start.spring.io/写好组名称，和项目名称,搜索eureka server，点击+，选择导出到本地。将下载好的项目导入idea。 然后在eureka server项目启动类添加注解 1@EnableEurekaServer 修改配置application.yml文件其中defaultZone前后注意空格，而且这个单词是关联不出来的。 123456789101112131415server: port: 8761eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ # 指示此实例是否应将其信息注册到eureka服务器以供其他服务发现，默认为false register-with-eureka: false server: # 启用自我保护机制，默认为true enable-self-preservation: falsespring: application: # 微服务名称 name: eureka 启动localhost:8761显示页面即为成功！ 创建eureka客户端登录spring官网 https://start.spring.io/修改项目名称，搜索eureka discovery client 。点击+ ，保存到本地保存到本地之后，在上一个项目中打开选择eureka客户端导入。 修改eureka客户端启动类添加注解 1@EnableDiscoveryClient pom文件添加 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件application.yml 12345678910spring: application: name: eureka-clientserver: port: 8711eureka: client: service-url: #注册中心路径，表示我们向这个注册中心注册服务，如果向多个注册中心注册，用“,”进行分隔 defaultZone: http://localhost:8761/eureka/ 启动服务端，启动客户端最简单的一个spring cloud + eureka 服务注册到此结束。全部是采用默认形式，最简单的一个项目搭建。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://gmaya.top/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://gmaya.top/tags/Eureka/"}]},{"title":"浅谈 MySQL 中优化 SQL 语句查询常用的 30 种方法","slug":"20200314","date":"2020-03-14T12:08:11.000Z","updated":"2020-03-14T12:14:22.388Z","comments":true,"path":"2020/20200314/","link":"","permalink":"https://gmaya.top/2020/20200314/","excerpt":"","text":"转载于网络，作者不详。 1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： 1select id from t where num=0 4、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from t where num=10 or num=20 可以这样查询： 123select id from t where num=10 union all select id from t where num=20 5、下面的查询也将导致全表扫描： 1select id from t where name like '%abc%' 若要提高效率，可以考虑全文检索。 6、in 和 not in 也要慎用，否则会导致全表扫描，如： 1select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： 1select id from t where num between 1 and 3 7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： 1select id from t where num=@num 可以改为强制查询使用索引： 1select id from t with(index(索引名)) where num=@num 8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： 1select id from t where num/2=100 应改为: 1select id from t where num=100*2 9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：name以abc开头的id 1select id from t where substring(name,1,3)='abc' ‘2005-11-30’生成的id 1select id from t where datediff(day,createdate,'2005-11-30')=0 应改为: 12select id from t where name like 'abc%' select id from t where createdate&gt;='2005-11-30' and createdate&lt;'2005-12-1' 10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 12、不要写一些没有意义的查询，如需要生成一个空表结构： 1select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： 1create table #t(...) 13、很多时候用 exists 代替 in 是一个好的选择： 1select num from a where num in(select num from b) 用下面的语句替换： 1select num from a where exists(select 1 from b where num=a.num) 14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 16、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21、避免频繁创建和删除临时表，以减少系统表资源的消耗。 22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30、尽量避免大事务操作，提高系统并发能力。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://gmaya.top/categories/mysql/"}],"tags":[{"name":"日常分享","slug":"日常分享","permalink":"https://gmaya.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]},{"title":"idea新建springboot项目pom文件报错","slug":"20200313","date":"2020-03-13T05:01:11.000Z","updated":"2020-03-13T07:35:43.468Z","comments":true,"path":"2020/20200313/","link":"","permalink":"https://gmaya.top/2020/20200313/","excerpt":"","text":"前言之前也有过类似的情况，只不过都是把spring-boot-starter-parent版本号改成本地仓库已经有的，然后继续开发。今天想写个demo，就新建了一个，然后版本号不一致，就一直报错，所以找了一天问题，才解决。太可怕了 新建springboot项目的问题使用idea，一路next，到最后生成项目然后pom文件报错我特意换了一个全新的maven，发现是因为jar拉不下来，就配置了国内镜像找到maven ，conf 打开 settings.xml。在mirrors里面写入 1234567891011121314151617181920212223242526272829303132&lt;!-- 阿里云镜像 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;ibiblio&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt; &lt;/mirror&gt;&lt;!-- 中央仓库在中国的镜像 --&gt; &lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;oneof the central mirrors in china&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 然后发现还是有点问题，有些拉不下来。继续设置idea，打开设置，搜索maven将上面的勾打上然后在VM Options下面输入 123-Dmaven.wagon.http.ssl.insecure=true-Dmaven.wagon.http.ssl.allowall=true-Dmaven.wagon.http.ssl.ignore.validity.dates=true 然后点击最右面maven，重新安装一下（拉完之后再把勾去掉，还原）此时已经解决了我所有报错的问题，然后启动项目是启动不起来的，因为没有web继续在pom加入spring-boot-starter-web 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 启动类中加入hello代码校验启动，浏览器输入http://localhost:8080/hello哎。真tm菜","categories":[{"name":"idea","slug":"idea","permalink":"https://gmaya.top/categories/idea/"}],"tags":[{"name":"java","slug":"java","permalink":"https://gmaya.top/tags/java/"}]},{"title":"hexo配置最新next主题的几个问题","slug":"20200312","date":"2020-03-12T05:01:11.000Z","updated":"2020-03-12T06:22:16.725Z","comments":true,"path":"2020/20200312/","link":"","permalink":"https://gmaya.top/2020/20200312/","excerpt":"","text":"前言截止到写这博客的时间，花费了一天左右的时间，将next主题美化了一下，以此记录。 模板我的博客使用next模板为Mist，打开主题配置文件 添加背景线条效果我是参考canvas-nest官方网站 创建文件在根目录的source 文件夹下创建_data文件夹，然后创建footer.swig注意不要将位置创建到主题里面去，然后将代码拷贝进去即可 1&lt;script color=\"0,0,0\" opacity=\"0.5\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"&gt;&lt;/script&gt; 其中color是颜色值，opacity是透明度，zIndex是现在层级，count是线条数量。 设置路径打开主题配置文件搜索 custom_file_path 将footer注释打开然后 hexo g ， hexo s ，启动看看效果 首页文章之间周围有边框刚开始这个首页文章之间没有边框，每个文章之间没有明显的间隔。效果：打开：\\themes\\next\\source\\css_common\\components\\post\\post.styl大概35行，找到motion.transition.post_block修改前： 12345if (hexo-config('motion.transition.post_block')) &#123; .post-block, .pagination, .comments &#123; opacity: 0; &#125; &#125; 修改后： 1234567891011if (hexo-config('motion.transition.post_block')) &#123; .post-block&#123; opacity: 0; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; .pagination, .comments &#123; opacity: 0; &#125;&#125; 然后 hexo g ， hexo s ，启动看看效果 修改文章之间的间隔默认的文章间距120px，有点大。 打开：\\themes\\next\\source\\css_schemes\\Mist_posts-expand.styl大概24行，找到.post-block:not修改前： 123.post-block:not(:first-child) &#123; margin-top: 120px;&#125; 将120px，修改为你想要的间距，我改成了20px修改后： 123.post-block:not(:first-child) &#123; margin-top: 20px;&#125; 评论数显示为英文问题我使用的Valine评论，但是文章标题下面显示的评论数为英文。打开：\\themes\\next\\languages\\zh-CN.yml在post下面新增： 1comments.valine: 评论数 注意空格，和下面保持对齐","categories":[{"name":"hexo","slug":"hexo","permalink":"https://gmaya.top/categories/hexo/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gmaya.top/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"获取qq音乐分享链接","slug":"0308","date":"2020-03-08T06:12:15.000Z","updated":"2020-03-12T06:39:50.287Z","comments":true,"path":"2020/0308/","link":"","permalink":"https://gmaya.top/2020/0308/","excerpt":"","text":"前言想要写个插件。支持qq，微信，在群里面点歌，这就要获取音乐接口的api 了。注：只允许个人学习使用。 分析通过浏览器分析音乐查询接口，分享接口，等等qq音乐搜索接口： 1https://c.y.qq.com/soso/fcgi-bin/client_search_cp?p=1&amp;n=1&amp;w=水手&amp;format=json&amp;inCharset=utf8&amp;outCharset=utf-8 其中：w=歌名，p=页数，n=条数，format=格式。剩下两个就是编码格式了 结果：得到以下几个参数：albumname：专辑albumid ： 专辑idalbummid : 专辑图片songname ：歌名singer[0].name:歌手名字songid ： 分享链接使用 音乐分享链接： 1https://i.y.qq.com/v8/playsong.html?songid= 例子： 1https://i.y.qq.com/v8/playsong.html?songid=4829638 获取专辑图片： 1https://y.gtimg.cn/music/photo_new/T002R300x300M000专辑图片.jpg 例子： 1https://y.gtimg.cn/music/photo_new/T002R300x300M000002MwneO44kDAi.jpg","categories":[{"name":"接口","slug":"接口","permalink":"https://gmaya.top/categories/%E6%8E%A5%E5%8F%A3/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gmaya.top/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"易语言对接腾讯ai智能闲聊","slug":"0307","date":"2020-03-07T03:29:25.000Z","updated":"2020-03-12T06:40:23.607Z","comments":true,"path":"2020/0307/","link":"","permalink":"https://gmaya.top/2020/0307/","excerpt":"","text":"介绍 腾讯闲聊服务基于AI Lab领先的NLP引擎能力、数据运算能力和千亿级互联网语料数据的支持，同时集成了广泛的知识问答能力，可实现上百种自定义属性配置，以及男、女不同的语言风格及说话方式，从而让聊天变得更睿智、简单和有趣 基础闲聊接口提供基于文本的基础聊天能力，可以让您的应用快速拥有具备上下文语义理解的机器聊天功能。 注：同时我将此接口制作成插件，可以应用在QQ和微信上。再也不怕自己一个人没人聊天了。 准备首先在腾讯ai官网注册自己的账号，将智能闲聊接入。然后在控制台-应用管理，找到刚接入的智能闲聊，在应用信息里面得到APPID，APPKEY两个参数。 基础闲聊API地址： 1https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat 入参： 编写代码getAI 方法 注意： #app_id 和 #app_key 就是上面申请得到的两个参数 1234567891011121314151617181920212223242526272829303132333435363738.版本 2.子程序 getAI, , 公开.参数 msg, 文本型, , 消息内容.局部变量 入参, 文本型.局部变量 time_stamp, 文本型.局部变量 nonce_str, 文本型.局部变量 session, 文本型.局部变量 question, 文本型.局部变量 sign, 文本型.局部变量 反参, 文本型.局部变量 JSON, 类_json.局部变量 回复消息, 文本型msg ＝ 删全部空 (msg)' 限制问题字数不能超过250字节 ，官方要求：非空且长度上限300字节.如果真 (取文本长度 (msg) ＞ 250) 返回 ().如果真结束time_stamp ＝ 时间_取现行时间戳 (真)nonce_str ＝ 文本_取随机字符 (16)session ＝ nonce_strquestion ＝ 编码_URL编码 (编码_gb2312到utf8 (msg), 真, )入参 ＝ “app_id=” ＋ #app_id ＋ “&amp;nonce_str=” ＋ nonce_str ＋ “&amp;question=” ＋ question ＋ “&amp;session=” ＋ session ＋ “&amp;time_stamp=” ＋ time_stamp' 入参一定要按照字典顺序排好，不然签名不对sign ＝ getSign (入参)入参 ＝ 入参 ＋ “&amp;sign=” ＋ sign反参 ＝ 编码_utf8到gb2312 (网页_访问S (“https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat”, 1, 入参, , , , , , , , , , , , , , , , , , )).如果真 (JSON.解析 (反参)) .如果真 (JSON.取通用属性 (“ret”, ) ＝ “0”) 回复消息 ＝ JSON.取通用属性 (“data.answer”, ) .如果真 (回复消息 ≠ “”) ' 得到智能ai的回答之后，做你想做的事情 .如果真结束 .如果真结束 getSign 方法 1234567.版本 2.子程序 getSign, 文本型.参数 入参, 文本型返回 (校验_取md5 (到字节集 (入参 ＋ “&amp;app_key=” ＋ #app_key), 真, )) 结束最后还可以在腾讯ai控制台中配置多重属性的闲聊画像，并且可配置的属性会持续增加，使闲聊的风格因您的喜好而不同。可以实时观看应用概况","categories":[{"name":"易语言","slug":"易语言","permalink":"https://gmaya.top/categories/%E6%98%93%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"易语言","slug":"易语言","permalink":"https://gmaya.top/tags/%E6%98%93%E8%AF%AD%E8%A8%80/"}]},{"title":"win10安装git","slug":"0306","date":"2020-03-06T09:57:08.000Z","updated":"2020-03-12T06:40:57.117Z","comments":true,"path":"2020/0306/","link":"","permalink":"https://gmaya.top/2020/0306/","excerpt":"","text":"下载git去git官网下载win版本64位安装全部下一步到结束 下载小乌龟去tortoriseGit官网下载64位小乌龟。然后下面还有一个中文语言包（不下载也行），Language Packs 下面的 Chinese, simplified先安装小乌龟，一路暴力下一步到结束。安装语言包，一路到结束。鼠标右键打开小乌龟设置，选择语言为中文，结束！ 生成SSH密钥鼠标右键 打开 Git Bash 输入下面的命令将邮箱换成你自己的邮箱、然后回车 1ssh-keygen -o -t rsa -b 4096 -C \"email@example.com\" 然后出现提示 密钥保存的位置。记一下使用默认密钥地址，继续回车提示你对密钥设置密码，这里无需设置，直接按回车键就好，要按两次回车键。之后就会显示保存成功然后打开默认位置，看一下有没有两个文件 添加密钥到Git服务器登录进来之后点击右上角的图标，选择settings设置SSH密钥选择 SSH keys然后 new SSH keys将刚才生成的公钥放进去保存即可。 配置本地私钥在文件夹空白处右键选择TortoiseGit的设置(setting)选项一直点下一步到下面的这个页面，中间会让你输入你的名称和邮箱（名称随便写，邮箱还写你那个邮箱），然后点击 生成PuTTY密钥对选择你刚才的私钥然后点击Save private key 保存成PuTTY 格式的私钥保存成功后关闭窗口 TortoiseGit克隆项目加载私钥右键Git克隆弹出如下窗口结束。","categories":[{"name":"工具","slug":"工具","permalink":"https://gmaya.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"安装git","slug":"安装git","permalink":"https://gmaya.top/tags/%E5%AE%89%E8%A3%85git/"}]},{"title":"酷q表情使用","slug":"0119","date":"2020-01-19T12:20:52.000Z","updated":"2020-03-12T06:41:18.702Z","comments":true,"path":"2020/0119/","link":"","permalink":"https://gmaya.top/2020/0119/","excerpt":"","text":"表情1在消息内添加 [CQ:face,id=XXX] 其中XXX为下面中的编号 例如你想添加微笑表情：[CQ:face,id=14][CQ:face,id=14][CQ:face,id=14] 结果就是三个微笑表情 表情2在消息内添加 [CQ:emoji,id=XXX] 其中XXX为下面中的编号 例如你想添加雪花表情：[CQ:emoji,id=10052]","categories":[{"name":"酷q","slug":"酷q","permalink":"https://gmaya.top/categories/%E9%85%B7q/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://gmaya.top/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"酷q","slug":"酷q","permalink":"https://gmaya.top/tags/%E9%85%B7q/"}]},{"title":"Excel导出导入","slug":"0116","date":"2020-01-16T14:40:12.000Z","updated":"2020-03-12T06:41:39.182Z","comments":true,"path":"2020/0116/","link":"","permalink":"https://gmaya.top/2020/0116/","excerpt":"","text":"1. EasyExcel介绍1.1 为什么使用EasyExcel？ Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便 快速、简单避免OOM的java处理Excel工具，64M内存1分钟内读取75M(46W行25列)的Excel。 写的内容大致和阅读官方文档差不多 2. 开始使用2.1 引入jar123456789101112&lt;!--easyexcel插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--lombok插件--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2.2 实体类根据自己的情况自定义表格导入导出实体类 12345678910111213141516171819202122232425262728293031323334353637package top.gmaya.demo.excelentity;import com.alibaba.excel.annotation.ExcelIgnore;import com.alibaba.excel.annotation.ExcelProperty;import com.alibaba.excel.annotation.format.DateTimeFormat;import com.alibaba.excel.annotation.write.style.ColumnWidth;import lombok.Data;import java.util.Date;/** * @ Description : 用户表格专用实体 * @ Author : GMaya * @ CreateDate : 2020/1/16 9:13 * @ Version : 1.0 */@Datapublic class UserExcel&#123; /** 生成报表时忽略，不生成次字段 */ @ExcelIgnore private Long id; /** 定义表头名称和位置,0代表第一列 */ @ExcelProperty(value = \"用户名称\",index = 0) private String userName; @ExcelProperty(value = \"用户年龄\",index = 1) private int userAge; @ExcelProperty(value = \"用户昵称\",index = 2) private String userNick; @ExcelProperty(value = \"用户地址\",index = 3) private String userAddress; /** 指定列宽 */ @ColumnWidth(20) /** 转化时间 */ @DateTimeFormat(value = \"yyyy-MM-dd\") @ExcelProperty(value = \"用户生日\",index = 4) private Date userBrithday;&#125; 2.3 ExcelUtil工具类根据实际情况封装成工具类，我就写了俩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package top.gmaya.demo.util;import com.alibaba.excel.EasyExcel;import com.alibaba.excel.read.listener.ReadListener;import com.alibaba.excel.support.ExcelTypeEnum;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLEncoder;import java.util.List;/** * @ Description : excel工具类 * @ Author : GMaya * @ CreateDate : 2020/1/16 9:35 * @ Version : 1.0 */public class ExcelUtil &#123; /** * 导出文件 到浏览器 * @param response 响应请求 * @param excelName excel名称 * @param sheetName sheet页面名称 * @param clazz 要转换的实体类类型 * @param data 要导出的数据 * @throws Exception 异常 */ public static void export2Web(HttpServletResponse response, String excelName, String sheetName, Class clazz, List data) throws Exception &#123; response.setContentType(\"application/vnd.ms-excel\"); response.setCharacterEncoding(\"utf-8\"); // 这里URLEncoder.encode可以防止中文乱码 excelName = URLEncoder.encode(excelName, \"UTF-8\"); response.setHeader(\"Content-disposition\", \"attachment;filename=\" + excelName + ExcelTypeEnum.XLSX.getValue()); EasyExcel.write(response.getOutputStream(), clazz).sheet(sheetName).doWrite(data); &#125; /** * 读取Excel表格 * @param excel 文件 * @param head 实体类映射 * @param readListener 模板的读取类 * @throws Exception */ public static void readExcel(MultipartFile excel, Class head,ReadListener readListener) throws Exception&#123; EasyExcel.read(excel.getInputStream(),head,readListener).sheet().doRead(); &#125;&#125; 2.4 模板读取类创建模板读取类， 这个是表格导入的时候需要的，表格中的数据将在这个类里面单独处理，根据类里面设置的数值进行存库，也就是10w条数据，每当1000条就存一下表，方便内存回收。 不然一次性读10w，要占多少。。。实际情况将下面的构造方法注释打开，相当于你在controller中调用，然后将Service传进来就ok了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package top.gmaya.demo.excelentity;import com.alibaba.excel.context.AnalysisContext;import com.alibaba.excel.event.AnalysisEventListener;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;/** * @ Description : 模板的读取类 * @ Author : GMaya * @ CreateDate : 2020/1/16 10:43 * @ Version : 1.0 */// 有个很重要的点 UserListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去@Slf4j public class UserListener extends AnalysisEventListener&lt;UserExcel&gt; &#123; /** * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收 */ private static final int BATCH_COUNT = 5; List&lt;UserExcel&gt; list = new ArrayList&lt;&gt;(); /** * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。 */ // private UserService userService; /* public UserListener()&#123; // 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数 userService = new UserService(); &#125;*/ /** * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来 * * @param userService */ /* public UserListener(UserService userService) &#123; this.userService = userService; &#125;*/ /** * 这个每一条数据解析都会来调用 * @param data * @param context * */ @Override public void invoke(UserExcel data, AnalysisContext context) &#123; log.info(\"解析到一条数据:&#123;&#125;\", data.getUserName()); list.add(data); if (list.size() &gt;= BATCH_COUNT) &#123; // 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM saveData(); // 存储完成清理 list list.clear(); &#125; &#125; @Override public void doAfterAllAnalysed(AnalysisContext context) &#123; saveData(); log.info(\"所有数据解析完成！\"); &#125; /** * 加上存储数据库 */ private void saveData() &#123; log.info(\"&#123;&#125;条数据，开始存储数据库！\", list.size()); // userService.saveBatch(list); log.info(\"存储数据库成功！\"); &#125;&#125; 2.5 controller测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package top.gmaya.demo.controller;import com.alibaba.excel.EasyExcel;import com.alibaba.excel.ExcelReader;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import top.gmaya.demo.entity.User;import top.gmaya.demo.excelentity.UserExcel;import top.gmaya.demo.excelentity.UserListener;import top.gmaya.demo.util.ExcelUtil;import javax.servlet.http.HttpServletResponse;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @ Description : 测试 * @ Author : GMaya * @ CreateDate : 2020/1/15 16:55 * @ Version : 1.0 */@Slf4j @RestController public class DemoController &#123; /** * 导出excel * @param response */ @GetMapping(\"/export2Web\") public void export2Web(HttpServletResponse response, String id) &#123; // 模拟数据 List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; User user = new User((long) i, \"张三\" + i, i, \"小三\" + i, \"杭州\" + i, new Date()); list.add(user); &#125; try &#123; ExcelUtil.export2Web(response, \"用户表\", \"用户信息\", UserExcel.class, list); &#125; catch (Exception e) &#123; log.error(\"报表导出异常:\", e); &#125; &#125; /** * 导入excel * @param file * @return */ @PostMapping(\"/exportImport\") public String exportImport(MultipartFile file) &#123; try &#123; ExcelUtil.readExcel(file, UserExcel.class, new UserListener()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"succeed\"; &#125;&#125; 3. 测试3.1 导出测试启动项目，浏览器访问接口直接弹框提示保存位置。保存查看里面内容 3.2 导入测试使用postman测试文件导入key：Content-Typevalue：multipart/form-data","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://gmaya.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/tags/Java/"},{"name":"工具类","slug":"工具类","permalink":"https://gmaya.top/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}]},{"title":"建站心得","slug":"0110","date":"2020-01-10T13:20:33.000Z","updated":"2020-03-12T06:41:55.167Z","comments":true,"path":"2020/0110/","link":"","permalink":"https://gmaya.top/2020/0110/","excerpt":"","text":"从偶然发现个人博客开始，就开始着手搭建一个自己的博客网站，也许写不出什么有技术含量的东西，但是也图个新鲜，练练手，记录一下自己的成长经历！但是就是这个随手开始弄得网站，前前后后花了将近一个月，SO,我要将自己的过程记录下来！ 1. 买服务器&lt;此步骤可以省略&gt;我是购买的腾讯云，首次大幅度优惠，99/年。当然，博客如果都是静态页面，也可以不需要服务器，直接部署到github，或者码云上，都是可以的（免费）。如果你只需要搭建博客不需要其他的，可以不买服务器，忽略即可。我是因为还要用服务器干点其他的。 2. 买域名&lt;此步骤可以省略&gt;我是在腾讯云打折5块钱买了一年的域名，虽然不买也行，用github自动生成的也中，但我不想要！ 2.1 备案使用国内服务器，域名不管是哪里的，都需要备案！反正我资料啥的一顿填，大概半个月备案成功！我刚开始买了之后大概一星期左右网站使用域名已经进不去了，一直让我去备案。 2.2 域名解析将域名解析到我的服务器 2.3 nginx代理我是使用的nginx代理的静态页面，然后将我生成好的博客页面直接放到服务器，配置好nginx的配置就ok，然后直接访问域名。当然也可以搞个tomcat放到里面。 2.4 SSL证书弄完之后我的访问域名是不安全的链接，所以我又免费申请了一个SSL证书，配置到nginx中，然后博客就可以https访问了。 3. hexo建站3.1 配置环境首先根据hexo官方网站将本地环境搭建起来，对于经常使用git提交拉取公司项目的人，很快都搞定了。 3.2 挑选模板直接在hexo官方网站挑选自己中意的博客模板，我默默挑了好多，中间改过好几次，总之挑一个自己喜欢的。 3.3 修改模板一般都是根据模板的博主介绍，一步一步一步一步一步一步修改成为自己的博客。总之我感觉这一步是最长的。 4. 写博客不积跬步，无以至千里；不积小流，无以成江海。在接下来的岁月写你想写的东西吧。","categories":[{"name":"自我抒写","slug":"自我抒写","permalink":"https://gmaya.top/categories/%E8%87%AA%E6%88%91%E6%8A%92%E5%86%99/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gmaya.top/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"认识酷q","slug":"kuq-know","date":"2019-12-30T13:41:04.000Z","updated":"2020-03-12T06:42:15.374Z","comments":true,"path":"2019/kuq-know/","link":"","permalink":"https://gmaya.top/2019/kuq-know/","excerpt":"","text":"##酷q是干嘛的 酷Q Air 是一个轻巧、免费、高效的机器人核心，功能需要安装“应用”实现。登录酷Q，完成教程后，建议 访问 酷Q应用发布板块，下载安装您所需要的应用，创造让大家喜爱并且属于你自己的专属机器人。 官网：酷q社区 通俗的讲就是，打造一个属于自己的qq机器人，有点类似于现在的q群管家，qq小冰。但是你可以把他的功能再次扩大！（活跃群气氛必不可少）。主要有：入群欢迎，问答，便民（查天气，查快递等），各种小游戏娱乐，关键词禁言等等，需要看代码功底，当然你也可以去社区下载别人分享的插件，直接使用。 我也是在偶然的机会认识到了酷q，然后就爱不释手，从0开始学习了易语言，然后写出了第一个酷q插件猜拳签到游戏，当然我并不满足，然后又写出了查电影，问答，查运势，查天气，查新闻，随机笑话等，当然这些我并没有发布出来， 因为这些第三方接口我是免费用的，每天有限制几百条， 所以不适合分享，只是在自己的群里面使用而已。 如果你和我一样刚刚认识酷q，那么你不妨看一下这个快速入门使用sdk进行酷q开发。由于教程很多，我就没得写了，如果有不懂的可以留言评论或者到关于我页面查看联系方式。 但是我是java开发者，使用易语言难免有所不习惯，所以参考了南荒喵大佬的教程，使用支持java的sdk进行开发。 到了最后我在此demo上又加上mybatis-plus，springboot，连接数据库，等一系列操作。 有的时候思路是个好东西，当我弄完之后，我不知道写什么东西了，整天都是配环境，搭建环境，但是到最后写插件内容的时候，迷茫了，写什么呢，写什么好呢，写什么会有人用呢，看社区里面，那都是人家写出来的，你再写一遍干嘛呢。 好多东西都是 从简单，到复杂，到迷茫，到不知所措。（服务器自己买了一个，酷q是用的免费的） 然后我就认识了jsoup，百度百科是这样说的 jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 然后我就又陷入了进去，忘记了游戏，忘记了时间。 希望前进的路上不再迷茫！","categories":[{"name":"酷q","slug":"酷q","permalink":"https://gmaya.top/categories/%E9%85%B7q/"}],"tags":[{"name":"酷q","slug":"酷q","permalink":"https://gmaya.top/tags/%E9%85%B7q/"}]},{"title":"idea在jdk1.8情况下使用反编译插件","slug":"idea-decompilation","date":"2019-12-30T05:41:01.000Z","updated":"2020-03-12T06:43:03.671Z","comments":true,"path":"2019/idea-decompilation/","link":"","permalink":"https://gmaya.top/2019/idea-decompilation/","excerpt":"","text":"前言使用JD-GUI在jdk1.8情况下失效，我也查找了好多办法，最后看到idea有默认的，只是没有打开，瞬间搞定，记录一下！ 没有反编译是显示compiled code 123public static void debug(java.lang.String... messages) &#123; /* compiled code */ &#125;public static void debug(java.lang.Object... messages) &#123; /* compiled code */ &#125; idea不需要安装任何插件， 比如JD-GUI（这个在jdk1.8还是打不开） 因为，安装idea默认有，只是没有打开罢了 打开setting –&gt;plugings 搜索 Java Bytecode Decompiler 勾选，然后重启idea （注意：你的其他反编译插件就不要开了，关掉） 重启之后会让你选择 是否同意使用此插件， 点击最左面accept，同意即可！","categories":[{"name":"自我抒写","slug":"自我抒写","permalink":"https://gmaya.top/categories/%E8%87%AA%E6%88%91%E6%8A%92%E5%86%99/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/tags/Java/"},{"name":"idea插件","slug":"idea插件","permalink":"https://gmaya.top/tags/idea%E6%8F%92%E4%BB%B6/"}]},{"title":"Java性能测试大比拼","slug":"property-compare","date":"2019-12-28T15:23:56.000Z","updated":"2020-03-12T06:48:46.402Z","comments":true,"path":"2019/property-compare/","link":"","permalink":"https://gmaya.top/2019/property-compare/","excerpt":"","text":"实体类转换哪个快？Map循环遍历哪个快？转换为字符串哪个快？测试，分析，看源码，看底层知识。 dao和vo实体转换比拼参与比拼的两个选手: org.springframework.beans.BeanUtils org.springframework.cglib.beans.BeanCopier 测试方式: 1234567891011121314151617181920public static void main(String[] args) &#123; int leng = 10000000; Stu stu = new Stu(); stu.setStuId(\"id\"); stu.setStuName(\"name\"); stu.setStuAge(12); stu.setStuClassId(\"ClassId\"); StuVO stuVO = new StuVO(); long l = System.currentTimeMillis(); for (int i = 0; i &lt; leng; i++) &#123; BeanCopier beanCopier = BeanCopier.create(stu.getClass(), stuVO.getClass(), false); beanCopier.copy(stu,stuVO,null); &#125; System.out.println(\"beanCopier.copy:\"+(System.currentTimeMillis()-l)); l = System.currentTimeMillis(); for (int i = 0; i &lt; leng; i++) &#123; BeanUtils.copyProperties(stu,stuVO); &#125; System.out.println(\"BeanUtils.copyProperties:\"+(System.currentTimeMillis()-l)); &#125; 比拼结果: 备注: 如果把BeanCopier.create放到循环外,效率还可以加快!!! 可能由于各方面原因,次数较少时测试不准 Map遍历几种方式比拼参与比拼的四个选手: keySet的for循环方式 keySet的iterator迭代器方式 entrySet的for循环方式 entrySet的iterator迭代器方式 测试方式: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 1; i++) &#123; map.put(i + \"\", i + \"AA\"); &#125; keySet(map); keySetIterator(map); entrySet(map); entrySetIterator(map); &#125; /** * keySet的for循环方式 * @param map */ public static void keySet(Map&lt;String, String&gt; map)&#123; long startTime = System.currentTimeMillis(); for (String key : map.keySet()) &#123; String value = map.get(key); &#125; long endTime = System.currentTimeMillis(); System.out.println(\"keySet运行时间\" + (endTime - startTime)); &#125; /** * keySet的iterator迭代器方式 * @param map */ public static void keySetIterator(Map&lt;String, String&gt; map)&#123; long startTime = System.currentTimeMillis(); Iterator&lt;String&gt; iterator = map.keySet().iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); String value = map.get(key); &#125; long endTime = System.currentTimeMillis(); System.out.println(\"keySetIterator运行时间\" + (endTime - startTime)); &#125; /** * entrySet的for循环方式 * @param map */ public static void entrySet(Map&lt;String, String&gt; map)&#123; long startTime = System.currentTimeMillis(); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; String key = entry.getKey(); String value = entry.getValue(); &#125; long endTime = System.currentTimeMillis(); System.out.println(\"entrySet运行时间\" + (endTime - startTime)); &#125; /** * entrySet的iterator迭代器方式 * @param map */ public static void entrySetIterator(Map&lt;String, String&gt; map)&#123; long startTime = System.currentTimeMillis(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = iterator.next(); String key = entry.getKey(); String value = entry.getValue(); &#125; long endTime = System.currentTimeMillis(); System.out.println(\"entrySetIterator运行时间\" + (endTime - startTime)); &#125; 比拼结果: 备注:可能由于各方面原因,次数较少时测试不准 基本数据类型转为字符串方法比拼参与比拼的三个选手: 基本数据类型.toString() String.valueOf(数据) 数据+”” 测试方法: 12345678910111213141516171819public static void main(String[] args) &#123; int end = 1000000000; Integer t = 1; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; end; i++)&#123; String str = t.toString(); &#125; System.out.println(\"Integer.toString()：\" + (System.currentTimeMillis() - startTime) + \"ms\"); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; end; i++)&#123; String str = String.valueOf(t); &#125; System.out.println(\"String.valueOf()：\" + (System.currentTimeMillis() - startTime) + \"ms\"); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; end; i++)&#123; String str = t + \"\"; &#125; System.out.println(\"t + '' :\" + (System.currentTimeMillis() - startTime) + \"ms\"); &#125; 比拼结果: 备注:可能由于各方面原因,次数较少时测试不准 123451.String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断2.Integer.toString()方法，直接调用3.t + \"\"底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://gmaya.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/tags/Java/"},{"name":"性能比较","slug":"性能比较","permalink":"https://gmaya.top/tags/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"}]},{"title":"Mybatis-plus之自动生成","slug":"Mybatis-plus","date":"2019-12-27T14:16:25.000Z","updated":"2020-03-12T06:48:26.950Z","comments":true,"path":"2019/Mybatis-plus/","link":"","permalink":"https://gmaya.top/2019/Mybatis-plus/","excerpt":"","text":"1. 前言本文章首次是在csdn上写的，本次发布到自己的博客中，增添一点色彩。 点击查看Mybatis-plus官方文档 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 2. 创建spring boot 项目使用idea默认生成即可 … 3. 修改pom文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-plus自动生成代码--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- velocity 模版引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!--swagger2--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 4. 修改application.yml文件123456789101112131415161718server: port: 8080spring: datasource: url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: admin driver-class-name: com.mysql.jdbc.Drivermybatis-plus: mapperLocations: classpath*:mapper/*.xml typeAliasesPackage: com.mybatis.plus.demo.model # mybatis 别名包扫描路径 global-config: db-config: logic-delete-value: 1 #逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #线上关闭sql日志打印 5. 修改启动类 6. 创建Mybatis-plus配置新建文件MyBatisPlusConfiguration 注意 : 如果使用mp自带的控制逻辑删除和控制版本号还有分页功能,则需要添加这个配置 12345678910111213141516171819202122232425262728293031323334353637package com.plus.demo.util;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.baomidou.mybatisplus.core.injector.ISqlInjector;import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;@Configurationpublic class MyBatisPlusConfiguration &#123; /** * 控制逻辑删除 * @return */ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125; /** * 控制版本号 * @return */ @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125; /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125;&#125; 7. 编写自动生成工具类注 : 直接把Controller/service/serviceImpl/dao/mapper/form/vo全部生成 此处使用默认velocity 模版引擎 则没有常用的crud方法,使用自己的模板则可以生成常用的crud方法 其中自定义模板中有工具类是公司自己的jar包,所以只推荐参考 拷贝mybatis-plus-generator jar包中的模板到自己项目resources下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.mybatis.plus.demo.util;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;import com.baomidou.mybatisplus.core.toolkit.StringPool;import com.baomidou.mybatisplus.core.toolkit.StringUtils;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.InjectionConfig;import com.baomidou.mybatisplus.generator.config.*;import com.baomidou.mybatisplus.generator.config.converts.MySqlTypeConvert;import com.baomidou.mybatisplus.generator.config.po.TableInfo;import com.baomidou.mybatisplus.generator.config.rules.DbColumnType;import com.baomidou.mybatisplus.generator.config.rules.IColumnType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * 代码生成器 * */public class MabatisPlusGenerator &#123; private static String path = \"E:\\\\idea\\\\springboot-mybatis-plus\"; //文件路径 private static String table = \"tm_user\"; //table名字 public static void main(String[] args) &#123; //1. 全局配置 GlobalConfig config = new GlobalConfig(); config.setActiveRecord(false) // 是否支持AR模式 .setAuthor(\"GMaya\") // 作者 .setSwagger2(true) // 使用Swagger .setOutputDir(path + \"/src/main/java\") // 生成路径 .setFileOverride(true) // 文件覆盖 .setIdType(IdType.AUTO) // 主键策略 // 自定义文件命名，注意 %s 会自动填充表实体属性！ .setServiceName(\"%sService\").setServiceImplName(\"%sServiceImpl\") .setControllerName(\"%sController\").setMapperName(\"%sDao\").setXmlName(\"%sMapper\") .setOpen(false) // 生成文件后 不打开文件夹 .setBaseResultMap(true) // XML ResultMap .setBaseColumnList(true); // XML columList //2. 数据源配置 DataSourceConfig dsConfig = new DataSourceConfig(); dsConfig.setDbType(DbType.MYSQL) // 设置数据库类型 .setDriverName(\"com.mysql.jdbc.Driver\") .setUrl( \"jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8\") .setUsername(\"root\").setPassword(\"admin\").setTypeConvert(new MySqlTypeConvert() &#123; @Override public IColumnType processTypeConvert(GlobalConfig globalConfig, String fieldType) &#123; if (fieldType.toLowerCase().contains(\"tinyint\")) &#123; return DbColumnType.BOOLEAN; &#125; //将数据库中datetime转换成date if (fieldType.toLowerCase().contains(\"datetime\")) &#123; return DbColumnType.DATE; &#125; return super.processTypeConvert(globalConfig, fieldType); &#125; &#125;); //3. 策略配置 StrategyConfig stConfig = new StrategyConfig(); stConfig.setColumnNaming(NamingStrategy.underline_to_camel) .setNaming(NamingStrategy.underline_to_camel) // 数据库表映射到实体的命名策略 .setEntityLombokModel(true) // 使用Lombok .setVersionFieldName(\"version\") // 数据库版本控制字段 .setLogicDeleteFieldName(\"status\") // 数据库逻辑删除字段 .setRestControllerStyle(true) .setSuperServiceClass(\"com.baomidou.mybatisplus.extension.service.IService\") .setInclude(new String[]&#123;table&#125;); // 生成的表 //4. 包名策略配置 PackageConfig pkConfig = new PackageConfig(); pkConfig.setParent(\"com.mybatis.plus.demo\").setMapper(\"dao\").setService(\"service\") .setServiceImpl(\"service.impl\").setController(\"controller\").setEntity(\"model\"); //5.自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; String templatePath = \"/templates/mapper.xml.vm\"; // 如果模板引擎是 velocity List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;(); // 自定义输出配置 focList.add(new FileOutConfig(templatePath) &#123; // 自定义配置会被优先输出 @Override public String outputFile(TableInfo tableInfo) &#123; // mapper自定义输出文件名 return path + \"/src/main/resources/mapper/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; &#125; &#125;); // ------------form vo 使用默认模板请注释-begin----------- templatePath = \"/templates/entityForm.java.vm\"; focList.add(new FileOutConfig(templatePath) &#123; // 自定义配置会被优先输出 @Override public String outputFile(TableInfo tableInfo) &#123; // form自定义输出文件名 return path + \"/src/main/java/com/mybatis/plus/demo/pojo/\" + tableInfo.getEntityName() + \"Form\" + StringPool.DOT_JAVA; &#125; &#125;); templatePath = \"/templates/entityVO.java.vm\"; focList.add(new FileOutConfig(templatePath) &#123; // 自定义配置会被优先输出 @Override public String outputFile(TableInfo tableInfo) &#123; // VO自定义输出文件名 return path + \"/src/main/java/com/mybatis/plus/demo/pojo/\" + tableInfo.getEntityName() + \"VO\" + StringPool.DOT_JAVA; &#125; &#125;); // ------------form vo 使用默认模板请注释-end----------- cfg.setFileOutConfigList(focList); // 6 配置模板 自定义模板/在resources/templates 可以编辑 TemplateConfig templateConfig = new TemplateConfig(); // 关闭默认 xml 生成，调整生成 至 根目录 templateConfig.setEntity(\"/templates/entity.java\").setService(\"/templates/service.java\") .setController(\"/templates/controller.java\").setMapper(\"/templates/mapper.java\") .setServiceImpl(\"/templates/serviceImpl.java\").setXml(null); //7. 整合配置 AutoGenerator ag = new AutoGenerator(); ag.setGlobalConfig(config).setDataSource(dsConfig).setStrategy(stConfig).setCfg(cfg) .setPackageInfo(pkConfig).setTemplate(templateConfig); //8. 执行 ag.execute(); &#125;&#125; 注 : 如果是使用自定义模板,请注意修改模板中的form,vo引入包路径等 使用默认模板请注释代码中生成form/vo代码 第一次运行可能有以下错误,如果没有请忽略 问题1 : The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents 解决 : set global time_zone=’+8:00’ 问题2 : 使用Lombok插件,Idea,Eclipse必须安装改插件,否则找不到get/set方法 解决 : IDEA安装Lombok步骤 Eclipse的自行百度 /滑稽 修改文件路径表名之后运行 生成结构图如下 perfect ! ! !","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://gmaya.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/tags/Java/"},{"name":"Mybatis-plus","slug":"Mybatis-plus","permalink":"https://gmaya.top/tags/Mybatis-plus/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-12-16T14:16:00.000Z","updated":"2020-04-02T08:22:57.307Z","comments":true,"path":"2019/hello-world/","link":"","permalink":"https://gmaya.top/2019/hello-world/","excerpt":"","text":"各种语言的Hello WorldJava1$ System.out.println(\"Hello,World!\"); 我说Java天下第一,你信么! C1$ printf(\"Hello,World!\"); C++1$ std::cout &lt;&lt; \"Hello,World!\" &lt;&lt; std::endl; Python1$ &gt;&gt;&gt; print(\"Hello,World!\") C#1$ Console.WriteLine(\"Hello,World!\"); PHP1$ echo \"Hello,World!\"; JavaScript12$ var sys = require(\"sys\"); sys.puts(\"Hello,World!\"); Ruby1$ puts \"Hello,World!\" R1$ print(\"Hello,World!\") SQL1$ select 'Hello,World!' from dual; HTML1$ &lt;p&gt;Hello,World!&lt;/p&gt; VB1$ MsgBox(\"Hello,World!\") Shell1$ echo \"Hello,World!\" Delphi1$ label1.Caption := 'Hello,World!'; TCL1$ % puts \"Hello,World!\" Pascal1$ writeln('Hello, world!') 我认输了, 我是菜鸟! 一个Hello, world! 打败我了","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://gmaya.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://gmaya.top/tags/Java/"}]}]}